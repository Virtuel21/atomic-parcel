<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic Parcel - Rhythm Delivery Chaos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            pointer-events: none;
            z-index: 100;
        }

        #score-display {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #ff6b35, 0 0 20px #ff6b35;
        }

        #combo-display {
            font-size: 1.5rem;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin-top: 5px;
        }

        #multiplier {
            font-size: 1.2rem;
            color: #00ff88;
        }

        #fragile-multiplier {
            margin-top: 6px;
            font-size: 1.1rem;
            color: #ff66cc;
            text-shadow: 0 0 15px rgba(255, 102, 204, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #fragile-multiplier.active {
            opacity: 1;
        }

        #performance-meter {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 220px;
            text-align: right;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #performance-meter .performance-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        #performance-meter .performance-status {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 4px;
        }

        #performance-meter .performance-percent {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        #performance-bar {
            margin-top: 6px;
            height: 14px;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow: hidden;
            position: relative;
        }

        #performance-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ff88, #2dff64);
            transition: width 0.2s ease, background 0.2s ease;
        }

        #performance-meter.warning #performance-fill {
            background: linear-gradient(90deg, #ffd166, #ff9f1c);
        }

        #performance-meter.danger #performance-fill {
            background: linear-gradient(90deg, #ff595e, #ff0054);
            animation: dangerPulse 0.6s infinite alternate;
        }

        @keyframes dangerPulse {
            0% { filter: brightness(0.9); }
            100% { filter: brightness(1.3); }
        }

        /* Combo flame effect */
        #combo-container {
            position: relative;
            display: inline-block;
        }

        #combo-flame {
            position: absolute;
            top: -20px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(ellipse at bottom, rgba(255, 100, 0, 0.5) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: -1;
        }

        #combo-container.on-fire #combo-flame {
            opacity: 1;
            animation: flameFlicker 0.2s infinite alternate;
        }

        @keyframes flameFlicker {
            0% { transform: scaleY(1); }
            100% { transform: scaleY(1.1); }
        }

        /* Rhythm indicator */
        #rhythm-bar {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 80px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            border: 2px solid #444;
            overflow: hidden;
        }

        #beat-line {
            position: absolute;
            left: 50%;
            top: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, #ff0066, #ff6b35);
            box-shadow: 0 0 20px #ff0066;
            z-index: 10;
        }

        .beat-note {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.5rem;
            color: white;
            transition: transform 0.1s;
        }

        .beat-note.cube {
            background: linear-gradient(135deg, #4a90d9, #2c5aa0);
            border: 3px solid #6bb3ff;
        }

        .beat-note.sphere {
            background: linear-gradient(135deg, #d94a4a, #a02c2c);
            border: 3px solid #ff6b6b;
            border-radius: 50%;
        }

        .beat-note.pizza {
            background: linear-gradient(135deg, #d9a54a, #a07c2c);
            border: 3px solid #ffcc6b;
        }

        .beat-note.fragile {
            width: 140px;
            height: 60px;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }

        .beat-note.express {
            width: 150px;
            height: 60px;
            background: transparent;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 14px;
        }

        .fragile-gem,
        .combo-gem {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #fff;
            z-index: 2;
        }

        .fragile-gem.cube {
            background: linear-gradient(135deg, #4a90d9, #2c5aa0);
            border: 3px solid #6bb3ff;
        }

        .fragile-gem.sphere {
            background: linear-gradient(135deg, #d94a4a, #a02c2c);
            border: 3px solid #ff6b6b;
        }

        .combo-gem.cube {
            background: linear-gradient(135deg, #4a90d9, #2c5aa0);
            border: 3px solid #6bb3ff;
        }

        .combo-gem.space {
            background: linear-gradient(135deg, #444, #222);
            border: 3px solid #888;
        }

        .fragile-link {
            position: absolute;
            width: 110px;
            height: 6px;
            background: linear-gradient(90deg, rgba(255,255,255,0.4), rgba(255,255,255,0.9), rgba(255,255,255,0.4));
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        }

        .express-link {
            position: absolute;
            width: 110px;
            height: 6px;
            background: linear-gradient(90deg, rgba(0,255,136,0.2), rgba(0,255,136,0.9), rgba(0,255,136,0.2));
            border-radius: 4px;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
        }

        .beat-note.hit {
            animation: noteHit 0.3s ease-out forwards;
        }

        @keyframes noteHit {
            0% { transform: translateY(-50%) scale(1); opacity: 1; }
            100% { transform: translateY(-50%) scale(1.5); opacity: 0; }
        }

        /* Controls display */
        #controls-display {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            pointer-events: none;
        }

        .control-key {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            opacity: 0.6;
            transition: all 0.1s;
        }

        .control-key.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 30px currentColor;
        }

        .control-key.cube-key {
            background: linear-gradient(135deg, #4a90d9, #2c5aa0);
            border: 3px solid #6bb3ff;
        }

        .control-key.sphere-key {
            background: linear-gradient(135deg, #d94a4a, #a02c2c);
            border: 3px solid #ff6b6b;
        }

        .control-key.pizza-key {
            background: linear-gradient(135deg, #d9a54a, #a07c2c);
            border: 3px solid #ffcc6b;
        }

        .key-letter {
            font-size: 1.8rem;
        }

        .key-icon {
            font-size: 0.8rem;
            margin-top: 2px;
        }

        .spacebar-icon {
            position: relative;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 3px solid #fff;
            display: inline-block;
            box-shadow: inset 0 0 0 2px rgba(255, 255, 255, 0.2);
        }

        .spacebar-icon::after {
            content: '';
            position: absolute;
            left: 4px;
            right: 4px;
            bottom: 6px;
            height: 5px;
            border-radius: 3px;
            background: #fff;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            z-index: 50;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Feedback text */
        .feedback-text {
            position: absolute;
            font-size: 2rem;
            font-weight: bold;
            pointer-events: none;
            animation: feedbackFloat 1s ease-out forwards;
            z-index: 200;
        }

        .feedback-text.perfect {
            color: #00ff88;
            text-shadow: 0 0 20px #00ff88;
        }

        .feedback-text.good {
            color: #ffd700;
            text-shadow: 0 0 20px #ffd700;
        }

        .feedback-text.ok {
            color: #ff9500;
            text-shadow: 0 0 20px #ff9500;
        }

        .feedback-text.miss {
            color: #ff3333;
            text-shadow: 0 0 20px #ff3333;
        }

        .feedback-text.break {
            color: #ff00ff;
            text-shadow: 0 0 30px #ff00ff;
            font-size: 2.5rem;
        }

        .feedback-text.ultimate {
            color: #00ffff;
            text-shadow: 0 0 40px #00ffff, 0 0 80px #00ffff;
            font-size: 3rem;
        }

        @keyframes feedbackFloat {
            0% { transform: translate(-50%, 0) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50px) scale(1.2); opacity: 0; }
        }

        /* Start screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 1000;
            overflow-y: auto;
            padding: 60px 20px 40px;
            gap: 20px;
        }

        #start-screen h1 {
            font-size: 4rem;
            color: #ff6b35;
            text-shadow: 0 0 30px #ff6b35;
            margin-bottom: 10px;
        }

        #start-screen h2 {
            font-size: 1.5rem;
            color: #888;
            margin-bottom: 30px;
            font-style: italic;
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            max-width: 550px;
            width: 100%;
        }

        .instructions h3 {
            color: #ffd700;
            margin-bottom: 15px;
        }

        .instructions p {
            color: #ccc;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .key-hint {
            display: inline-block;
            padding: 5px 12px;
            background: #444;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            margin: 0 3px;
            min-width: 40px;
            text-align: center;
        }

        /* Key binding configuration */
        .key-config {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }

        .key-config label {
            color: #ccc;
            font-size: 1rem;
        }

        .key-config-btn {
            padding: 8px 20px;
            background: #444;
            border: 2px solid #666;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            min-width: 80px;
            text-align: center;
            transition: all 0.2s;
        }

        .key-config-btn:hover {
            background: #555;
            border-color: #888;
        }

        .key-config-btn.listening {
            background: #ff6b35;
            border-color: #ff6b35;
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }

        .menu-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-select {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .difficulty-btn {
            padding: 10px 18px;
            border-radius: 20px;
            border: 2px solid #555;
            background: rgba(0, 0, 0, 0.35);
            color: #fff;
            cursor: pointer;
            font-weight: bold;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }

        .difficulty-btn.active,
        .difficulty-btn:hover {
            border-color: #ff6b35;
            box-shadow: 0 0 15px rgba(255, 107, 53, 0.6);
            background: rgba(255, 107, 53, 0.2);
        }

        /* Music upload */
        .music-upload {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 10px;
        }

        .music-upload label {
            color: #ccc;
            font-size: 0.95rem;
        }

        .music-upload select {
            background: rgba(0, 0, 0, 0.45);
            border: 2px solid #ff6b35;
            border-radius: 10px;
            color: #fff;
            padding: 10px 12px;
            font-weight: bold;
        }

        .music-upload select:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255, 107, 53, 0.4);
        }

        .music-upload input[type="file"] {
            color: #fff;
            background: rgba(0, 0, 0, 0.35);
            border: 2px dashed #ff6b35;
            border-radius: 10px;
            padding: 12px;
            cursor: pointer;
        }

        .track-status {
            font-size: 0.95rem;
            color: #ffd700;
        }

        .track-status span {
            color: #fff;
            font-weight: bold;
        }

        .music-hint {
            color: #aaa;
            font-size: 0.85rem;
        }


        .analysis-tool {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 15px;
            max-width: 550px;
            width: 100%;
        }

        .analysis-tool h3 {
            color: #7bdff6;
            margin-bottom: 10px;
        }

        .analysis-tool .analysis-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .analysis-tool button {
            padding: 10px 18px;
            border-radius: 8px;
            border: none;
            font-weight: bold;
            cursor: pointer;
            background: #2c5aa0;
            color: #fff;
        }

        .analysis-tool button.secondary {
            background: #444;
        }

        .analysis-tool button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .analysis-progress {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 999px;
            overflow: hidden;
            margin-top: 8px;
            display: none;
        }

        .analysis-progress.active {
            display: block;
        }

        .analysis-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff88, #4a90d9);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
            transition: width 0.2s ease;
        }

        .analysis-status {
            font-size: 0.95rem;
            color: #ddd;
            margin-top: 8px;
        }

        .analysis-status strong {
            color: #ffd700;
        }

        .menu-btn {
            padding: 15px 40px;
            font-size: 1.3rem;
            background: linear-gradient(135deg, #ff6b35, #ff3366);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px #ff6b35;
        }

        .menu-btn.secondary {
            background: linear-gradient(135deg, #444, #333);
        }

        .menu-btn.secondary:hover {
            box-shadow: 0 0 20px #888;
        }

        /* Pause screen */
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #pause-screen h1 {
            font-size: 4rem;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            margin-bottom: 40px;
        }

        /* Game over screen */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        #game-over-screen h1 {
            font-size: 3rem;
            color: #ff6b35;
            margin-bottom: 20px;
        }

        #final-score {
            font-size: 4rem;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700;
            margin-bottom: 10px;
        }

        #stats {
            color: #888;
            font-size: 1.2rem;
            margin-bottom: 30px;
            text-align: center;
        }

        #stats p {
            margin: 5px 0;
        }

        #game-over-message {
            color: #ffd700;
            font-size: 1.1rem;
            margin-top: 15px;
            max-width: 520px;
            text-align: center;
        }

        /* Power meter */
        #power-meter {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid #444;
            overflow: hidden;
        }

        #power-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(180deg, #ff0066, #ff6b35, #ffd700);
            transition: height 0.05s;
        }

        #power-label {
            position: absolute;
            right: 70px;
            top: 50%;
            transform: translateY(-50%);
            color: #fff;
            font-size: 0.9rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        /* Ultimate bar */
        #ultimate-container {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #ultimate-bar {
            width: 30px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            border: 2px solid #444;
            overflow: hidden;
            position: relative;
        }

        #ultimate-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(180deg, #00ffff, #0088ff, #0044aa);
            transition: height 0.2s;
        }

        #ultimate-bar.ready {
            border-color: #00ffff;
            box-shadow: 0 0 20px #00ffff;
            animation: ultReady 0.5s infinite alternate;
        }

        #ultimate-bar.active {
            border-color: #ff00ff;
            box-shadow: 0 0 30px #ff00ff;
        }

        @keyframes ultReady {
            0% { box-shadow: 0 0 20px #00ffff; }
            100% { box-shadow: 0 0 40px #00ffff; }
        }

        #ultimate-label {
            color: #00ffff;
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
        }

        #ultimate-key {
            background: #00ffff;
            color: #000;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #ultimate-key.visible {
            opacity: 1;
            animation: pulse 0.5s infinite alternate;
        }

        /* Combo meter */
        #combo-meter {
            position: absolute;
            left: 20px;
            top: 120px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #444;
        }

        #combo-meter.fire-1 { border-color: #ffaa00; }
        #combo-meter.fire-2 { border-color: #ff6600; box-shadow: 0 0 15px #ff6600; }
        #combo-meter.fire-3 { border-color: #ff0000; box-shadow: 0 0 25px #ff0000; }
        #combo-meter.fire-4 { border-color: #ff00ff; box-shadow: 0 0 35px #ff00ff; }

        #combo-meter .combo-label {
            color: #888;
            font-size: 0.8rem;
        }

        #combo-meter .combo-value {
            color: #fff;
            font-size: 2rem;
            font-weight: bold;
        }

        #combo-meter .combo-mult {
            color: #00ff88;
            font-size: 1rem;
        }

        /* Broken packages counter */
        #broken-counter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 0, 102, 0.3);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #ff0066;
        }

        #broken-counter span {
            color: #ff0066;
            font-size: 1.5rem;
            font-weight: bold;
        }

        #broken-label {
            color: #ff9999;
            font-size: 0.9rem;
            display: block;
            margin-top: 5px;
        }

        /* Perfect streak counter */
        #perfect-streak {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.2);
            padding: 10px 25px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #perfect-streak.visible {
            opacity: 1;
        }

        #perfect-streak span {
            color: #00ff88;
            font-size: 1.2rem;
            font-weight: bold;
        }

        /* Timer */
        #timer {
            position: absolute;
            top: 20px;
            left: 140px;
            color: #fff;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* Ultimate active overlay */
        #ultimate-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 90;
            opacity: 0;
            background: radial-gradient(ellipse at center, rgba(0, 255, 255, 0.1) 0%, transparent 70%);
            transition: opacity 0.3s;
        }

        #ultimate-overlay.active {
            opacity: 1;
            animation: ultOverlay 0.5s infinite alternate;
        }

        @keyframes ultOverlay {
            0% { background: radial-gradient(ellipse at center, rgba(0, 255, 255, 0.1) 0%, transparent 70%); }
            100% { background: radial-gradient(ellipse at center, rgba(255, 0, 255, 0.15) 0%, transparent 70%); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Start Screen -->
        <div id="start-screen">
            <h1>ATOMIC PARCEL</h1>
            <h2>"Livraison express... ou presque"</h2>

            <div class="instructions">
                <h3>Comment jouer</h3>
                <p>Lancez les colis dans le camion en rythme avec la musique!</p>
                <p><strong>Visez avec la souris</strong> - Plus vous visez haut, plus vous lancez fort!</p>
                <p><strong>Timing:</strong> Appuyez quand la note atteint la ligne centrale</p>
                <p><strong>Combo:</strong> Enchainez les hits pour augmenter votre puissance!</p>
                <p><strong>Erreur:</strong> Une note ratée ou une mauvaise touche fait perdre des points. Si vous restez trop longtemps sous un taux de réussite minimal, c'est terminé.</p>
                <p><strong>Ultime:</strong> 10 notes réussies = mode automatique 10 sec!</p>
                <p><strong>Fragile:</strong> Appuyez sur <span class="key-hint">A</span> + <span class="key-hint">P</span> ensemble pour lancer le colis FRAGILE.</p>
                <p><strong>Express:</strong> Appuyez sur <span class="key-hint">A</span> + <span class="key-hint"><span class="spacebar-icon"></span></span> pour expédier un colis express.</p>
            </div>

            <div class="instructions">
                <h3>Configuration des touches</h3>
                <div class="key-config">
                    <label>CUBE:</label>
                    <button class="key-config-btn" data-action="cube" id="key-cube-btn">A</button>
                </div>
                <div class="key-config">
                    <label>SPHERE:</label>
                    <button class="key-config-btn" data-action="sphere" id="key-sphere-btn">P</button>
                </div>
                <div class="key-config">
                    <label>PIZZA:</label>
                    <button class="key-config-btn" data-action="pizza" id="key-pizza-btn">ESPACE</button>
                </div>
                <div class="key-config">
                    <label>ULTIME:</label>
                    <button class="key-config-btn" data-action="ultimate" id="key-ult-btn">E</button>
                </div>
                <p style="color: #888; font-size: 0.9rem; margin-top: 10px;">Cliquez sur une touche pour la modifier</p>
            </div>

            <div class="instructions">
                <h3>Votre musique</h3>
                <p>Chargez une chanson pour caler l'apparition des colis sur votre rythme.</p>
                <div class="music-upload">
                    <label for="track-select">Musique par défaut</label>
                    <select id="track-select">
                        <option value="atomic-parcel">Atomic Parcel</option>
                        <option value="atomic-parcel-2">Atomic Parcel 2</option>
                        <option value="upload">Import personnalisé</option>
                        <option value="none">Aucune</option>
                    </select>
                    <input type="file" id="music-upload" accept="audio/*">
                    <div class="track-status">Piste: <span id="track-status">Aucune</span></div>
                    <div class="music-hint">La détection de beat adapte le tempo automatiquement.</div>
                </div>
            </div>

            <div class="analysis-tool">
                <h3>Outil de map rythmique</h3>
                <p class="music-hint">Importez une musique pour détecter les temps forts, estimer le BPM et générer une map jouable.</p>
                <input type="file" id="analysis-upload" accept="audio/*">
                <div class="analysis-actions">
                    <button id="analyze-btn">Analyser</button>
                    <button id="export-btn" class="secondary" disabled>Exporter JSON</button>
                </div>
                <div class="analysis-status">
                    BPM estimé : <strong id="analysis-bpm">--</strong> |
                    Notes quantifiées : <strong id="analysis-notes">0</strong> |
                    Décalage : <strong id="analysis-offset">--</strong>
                </div>
                <div class="analysis-status" id="analysis-message">Aucune analyse en cours.</div>
                <div class="analysis-progress" id="analysis-progress">
                    <div class="analysis-progress-fill" id="analysis-progress-fill"></div>
                </div>
            </div>

            <div class="instructions">
                <h3>Difficulté</h3>
                <p>Choisissez la densité de notes par seconde.</p>
                <div class="difficulty-select">
                    <button class="difficulty-btn" data-difficulty="easy">EASY (0-3/s)</button>
                    <button class="difficulty-btn active" data-difficulty="middle">MIDDLE (4-5/s)</button>
                    <button class="difficulty-btn" data-difficulty="hard">HARD (6-7/s)</button>
                    <button class="difficulty-btn" data-difficulty="extreme">EXTREME (10/s)</button>
                </div>
            </div>

            <div class="menu-buttons">
                <button class="menu-btn" id="start-btn">COMMENCER LE CHAOS</button>
            </div>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen">
            <h1>PAUSE</h1>
            <div class="menu-buttons">
                <button class="menu-btn" id="resume-btn">REPRENDRE</button>
                <button class="menu-btn secondary" id="quit-btn">QUITTER</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen">
            <h1>FIN DU SERVICE!</h1>
            <div id="final-score">0</div>
            <div id="stats">
                <p>Colis explosés: <span id="stat-broken">0</span></p>
                <p>Combo max: <span id="stat-combo">0</span></p>
                <p>Précision: <span id="stat-accuracy">0%</span></p>
                <p>Ultimes déclenchés: <span id="stat-ultimates">0</span></p>
            </div>
            <div id="game-over-message"></div>
            <div class="menu-buttons">
                <button class="menu-btn" id="restart-btn">REJOUER</button>
                <button class="menu-btn secondary" id="menu-btn">MENU</button>
            </div>
        </div>

        <!-- HUD -->
        <div id="hud">
            <div id="score-display">0</div>
            <div id="fragile-multiplier">FRAGILE x3</div>
            <div id="performance-meter" class="safe">
                <div class="performance-label">RYTHME</div>
                <div id="performance-bar">
                    <div id="performance-fill"></div>
                </div>
                <div class="performance-status">OK</div>
                <div class="performance-percent">100%</div>
            </div>
        </div>

        <!-- Timer -->
        <div id="timer">1:30</div>

        <!-- Perfect streak -->
        <div id="perfect-streak">
            <span id="streak-value">0</span> PARFAITS!
        </div>

        <!-- Combo meter -->
        <div id="combo-meter">
            <div class="combo-label">COMBO</div>
            <div class="combo-value" id="combo-value">0</div>
            <div class="combo-mult">x<span id="mult-value">1</span></div>
        </div>

        <!-- Broken counter -->
        <div id="broken-counter">
            <span id="broken-value">0</span>
            <span id="broken-label">EXPLOSES</span>
        </div>

        <!-- Ultimate bar -->
        <div id="ultimate-container">
            <div id="ultimate-label">ULTIME</div>
            <div id="ultimate-bar">
                <div id="ultimate-fill" style="height: 0%"></div>
            </div>
            <div id="ultimate-key">E</div>
        </div>

        <!-- Power meter -->
        <div id="power-meter">
            <div id="power-fill" style="height: 50%"></div>
        </div>
        <div id="power-label">PUISSANCE</div>

        <!-- Ultimate overlay -->
        <div id="ultimate-overlay"></div>

        <!-- Crosshair -->
        <div id="crosshair"></div>

        <!-- Rhythm bar -->
        <div id="rhythm-bar">
            <div id="beat-line"></div>
        </div>

        <!-- Controls display -->
        <div id="controls-display">
            <div class="control-key cube-key" id="key-a">
                <span class="key-letter" id="display-key-cube">A</span>
                <span class="key-icon">CUBE</span>
            </div>
            <div class="control-key sphere-key" id="key-p">
                <span class="key-letter" id="display-key-sphere">P</span>
                <span class="key-icon">SPHERE</span>
            </div>
            <div class="control-key pizza-key" id="key-space">
                <span class="key-letter" id="display-key-pizza">_</span>
                <span class="key-icon">PIZZA</span>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js"></script>
    <!-- Cannon.js for physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        // ============================================
        // ATOMIC PARCEL - Rhythm Delivery Chaos
        // ============================================

        // Key bindings (configurable)
        const keyBindings = {
            cube: 'a',
            sphere: 'p',
            pizza: ' ',
            ultimate: 'e'
        };

        const trailerDimensions = {
            width: 2.4,
            height: 2.8,
            length: 10
        };

        const trailerModelUrl = 'low_poly_truck.glb';

        // Game state
        const gameState = {
            score: 0,
            combo: 0,
            maxCombo: 0,
            multiplier: 1,
            brokenPackages: 0,
            totalNotes: 0,
            hitNotes: 0,
            perfectStreak: 0,
            ultimateCharge: 0,
            ultimateChargePoints: 0,
            ultimateActive: false,
            ultimateTimer: 0,
            ultimatesUsed: 0,
            isPlaying: false,
            isPaused: false,
            bpm: 120,
            beatInterval: 500,
            lastBeatTime: 0,
            mouseY: 0.5,
            power: 0.5,
            comboPower: 1, // Multiplier for throw power based on combo
            fragileMultiplier: 1,
            fragileTimer: 0,
            recentNoteResults: [],
            dangerTimer: 0
        };

        const difficultySettings = {
            easy: { min: 0, max: 3 },
            middle: { min: 4, max: 5 },
            hard: { min: 6, max: 7 },
            extreme: { min: 10, max: 10 }
        };

        let currentDifficulty = 'middle';
        let maxNotesPerSecond = difficultySettings[currentDifficulty].max;
        let minNotesPerSecond = difficultySettings[currentDifficulty].min;
        const noteSpawnTimestamps = [];
        let lastNoteSpawnTime = 0;

        const BASE_NOTE_SPEED = 300;
        const NOTE_WIDTH = 60;
        const FRAGILE_NOTE_WIDTH = 140;
        const EXPRESS_NOTE_WIDTH = 150;
        const NOTE_SPACING = 20;
        let noteSpeed = BASE_NOTE_SPEED;

        // Constants
        const ULTIMATE_CHARGE_REQUIRED = 10;
        const ULTIMATE_DURATION = 10000; // 10 seconds
        const PACKAGE_BREAK_COMBO_REQUIRED = 10;
        const DEFAULT_GAME_DURATION = 90000; // 90 seconds
        const FRAGILE_MULTIPLIER = 3;
        const FRAGILE_MULTIPLIER_DURATION = 8000;
        const COMBO_NOTE_GAP = 240;
        const MISS_SCORE_PENALTY = 50;
        const PERFORMANCE_WINDOW_MS = 8000;
        const PERFORMANCE_REQUIRED_ACCURACY = 0.6;
        const PERFORMANCE_DANGER_DURATION = 4000;
        const PERFORMANCE_MIN_NOTES = 6;
        const TRUCK_DIMENSIONS = {
            width: 2.4,
            height: 2.8,
            length: 10,
            floorY: 0.85,
            doorZ: 2.2
        };
        const TRUCK_CAPACITY = 28;
        const TRUCK_OVERFLOW_LIMIT = 6;

        // DOM elements
        const elements = {
            container: document.getElementById('game-container'),
            startScreen: document.getElementById('start-screen'),
            pauseScreen: document.getElementById('pause-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            startBtn: document.getElementById('start-btn'),
            resumeBtn: document.getElementById('resume-btn'),
            quitBtn: document.getElementById('quit-btn'),
            restartBtn: document.getElementById('restart-btn'),
            menuBtn: document.getElementById('menu-btn'),
            scoreDisplay: document.getElementById('score-display'),
            comboValue: document.getElementById('combo-value'),
            multValue: document.getElementById('mult-value'),
            brokenValue: document.getElementById('broken-value'),
            rhythmBar: document.getElementById('rhythm-bar'),
            powerFill: document.getElementById('power-fill'),
            keyA: document.getElementById('key-a'),
            keyP: document.getElementById('key-p'),
            keySpace: document.getElementById('key-space'),
            finalScore: document.getElementById('final-score'),
            statBroken: document.getElementById('stat-broken'),
            statCombo: document.getElementById('stat-combo'),
            statAccuracy: document.getElementById('stat-accuracy'),
            statUltimates: document.getElementById('stat-ultimates'),
            ultimateBar: document.getElementById('ultimate-bar'),
            ultimateFill: document.getElementById('ultimate-fill'),
            ultimateKey: document.getElementById('ultimate-key'),
            ultimateOverlay: document.getElementById('ultimate-overlay'),
            perfectStreak: document.getElementById('perfect-streak'),
            streakValue: document.getElementById('streak-value'),
            comboMeter: document.getElementById('combo-meter'),
            timer: document.getElementById('timer'),
            displayKeyCube: document.getElementById('display-key-cube'),
            displayKeySphere: document.getElementById('display-key-sphere'),
            displayKeyPizza: document.getElementById('display-key-pizza'),
            keyCubeBtn: document.getElementById('key-cube-btn'),
            keySphereBtn: document.getElementById('key-sphere-btn'),
            keyPizzaBtn: document.getElementById('key-pizza-btn'),
            keyUltBtn: document.getElementById('key-ult-btn'),
            trackSelect: document.getElementById('track-select'),
            musicUpload: document.getElementById('music-upload'),
            trackStatus: document.getElementById('track-status'),
            difficultyButtons: document.querySelectorAll('.difficulty-btn'),
            analysisUpload: document.getElementById('analysis-upload'),
            analyzeBtn: document.getElementById('analyze-btn'),
            exportBtn: document.getElementById('export-btn'),
            analysisBpm: document.getElementById('analysis-bpm'),
            analysisNotes: document.getElementById('analysis-notes'),
            analysisOffset: document.getElementById('analysis-offset'),
            analysisMessage: document.getElementById('analysis-message'),
            analysisProgress: document.getElementById('analysis-progress'),
            analysisProgressFill: document.getElementById('analysis-progress-fill'),
            fragileMultiplier: document.getElementById('fragile-multiplier'),
            gameOverMessage: document.getElementById('game-over-message'),
            performanceMeter: document.getElementById('performance-meter'),
            performanceFill: document.getElementById('performance-fill'),
            performanceStatus: document.querySelector('#performance-meter .performance-status'),
            performancePercent: document.querySelector('#performance-meter .performance-percent')
        };

        // Three.js variables
        let scene, camera, renderer;
        let truck;
        let packages = [];
        let particles = [];

        // Cannon.js physics
        let world;

        // Audio context
        let audioContext;
        let gainNode;
        let analyserNode;
        let userTrack;
        let userTrackSource;
        let useUserTrack = false;
        let analysisInProgress = false;
        let pendingTrackPlayback = false;
        let lastUploadedTrackName = '';

        const defaultTracks = {
            'atomic-parcel': {
                name: 'Atomic Parcel',
                url: 'atomic parcel.mp3'
            },
            'atomic-parcel-2': {
                name: 'Atomic Parcel 2',
                url: 'atomic parcel-2.mp3'
            }
        };

        // Analysis tool state
        let analysisBuffer = null;
        let analysisResults = {
            bpm: 0,
            offset: 0,
            notes: [],
            onsets: [],
            subdivision: 4
        };

        // Beat notes on screen
        let beatNotes = [];
        let noteId = 0;

        // Key binding listener
        let listeningForKey = null;

        // Pressed keys state
        const pressedKeys = {};
        let lastFragileTrigger = 0;

        // Beat detection state
        const beatDetector = {
            energyAvg: 0,
            energyHistory: [],
            lastBeatTime: 0,
            prevBeatTime: 0,
            minInterval: 0.18,
            sensitivity: 1.15,
            historySize: 45
        };

        // Get display name for key
        function getKeyDisplayName(key) {
            if (key === ' ') return 'ESPACE';
            if (key === 'arrowup') return '↑';
            if (key === 'arrowdown') return '↓';
            if (key === 'arrowleft') return '←';
            if (key === 'arrowright') return '→';
            return key.toUpperCase();
        }

        function setKeyDisplay(element, key, { allowIcon = false } = {}) {
            if (allowIcon && key === ' ') {
                element.innerHTML = '<span class="spacebar-icon"></span>';
                return;
            }
            element.textContent = getKeyDisplayName(key);
        }

        // Update key display
        function updateKeyDisplays() {
            setKeyDisplay(elements.displayKeyCube, keyBindings.cube);
            setKeyDisplay(elements.displayKeySphere, keyBindings.sphere);
            setKeyDisplay(elements.displayKeyPizza, keyBindings.pizza, { allowIcon: true });

            elements.keyCubeBtn.textContent = getKeyDisplayName(keyBindings.cube);
            elements.keySphereBtn.textContent = getKeyDisplayName(keyBindings.sphere);
            elements.keyPizzaBtn.textContent = getKeyDisplayName(keyBindings.pizza);
            elements.keyUltBtn.textContent = getKeyDisplayName(keyBindings.ultimate);
        }

        function updateDifficultySelection(selected) {
            currentDifficulty = selected;
            const settings = difficultySettings[selected];
            minNotesPerSecond = settings.min;
            maxNotesPerSecond = settings.max;
            updateNoteSpeed();
            elements.difficultyButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.difficulty === selected);
            });
        }

        function updateNoteSpeed() {
            const spacing = NOTE_WIDTH + NOTE_SPACING;
            if (maxNotesPerSecond > 0) {
                noteSpeed = Math.max(BASE_NOTE_SPEED, spacing * maxNotesPerSecond);
            } else {
                noteSpeed = BASE_NOTE_SPEED;
            }
        }

        // Key binding click handlers
        function setupKeyBindingListeners() {
            document.querySelectorAll('.key-config-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove listening state from all buttons
                    document.querySelectorAll('.key-config-btn').forEach(b => b.classList.remove('listening'));

                    // Set this button to listening
                    btn.classList.add('listening');
                    listeningForKey = btn.dataset.action;
                    btn.textContent = '...';
                });
            });
        }

        function setupDifficultyListeners() {
            elements.difficultyButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    updateDifficultySelection(btn.dataset.difficulty);
                });
            });
        }

        // Handle key binding
        function handleKeyBinding(e) {
            if (!listeningForKey) return;

            e.preventDefault();
            const key = e.key.toLowerCase();

            // Check if key is already bound to something else
            for (const [action, boundKey] of Object.entries(keyBindings)) {
                if (boundKey === key && action !== listeningForKey) {
                    // Swap keys
                    keyBindings[action] = keyBindings[listeningForKey];
                }
            }

            keyBindings[listeningForKey] = key;

            // Update displays
            updateKeyDisplays();

            // Remove listening state
            document.querySelectorAll('.key-config-btn').forEach(b => b.classList.remove('listening'));
            listeningForKey = null;
        }

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 15, 60);

            // Camera - vue depuis le quai
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.5, 10);
            camera.lookAt(0, 2, -5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            elements.container.insertBefore(renderer.domElement, elements.container.firstChild);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404050, 0.4);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 15, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -15;
            mainLight.shadow.camera.right = 15;
            mainLight.shadow.camera.top = 15;
            mainLight.shadow.camera.bottom = -15;
            scene.add(mainLight);

            // Warehouse lights
            const warehouseLight1 = new THREE.PointLight(0xffaa55, 0.8, 25);
            warehouseLight1.position.set(-4, 5, 5);
            scene.add(warehouseLight1);

            const warehouseLight2 = new THREE.PointLight(0xffaa55, 0.8, 25);
            warehouseLight2.position.set(4, 5, 5);
            scene.add(warehouseLight2);

            // Create environment
            createWarehouseEnvironment();
            createTruck();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }

        // Create warehouse/dock environment
        function createWarehouseEnvironment() {
            // Ground - concrete floor
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x555566,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Warehouse back wall
            const wallGeometry = new THREE.BoxGeometry(20, 8, 0.5);
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x444455,
                roughness: 0.7
            });
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 4, 12);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Side walls
            const sideWallGeometry = new THREE.BoxGeometry(0.5, 8, 15);

            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-10, 4, 5);
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(10, 4, 5);
            rightWall.receiveShadow = true;
            scene.add(rightWall);

        }

        function buildProceduralTrailer(targetGroup) {
            const { width: trailerWidth, height: trailerHeight, length: trailerLength } = trailerDimensions;

            // Materials
            const metalMaterial = new THREE.MeshStandardMaterial({
                color: 0x888899,
                roughness: 0.4,
                metalness: 0.6
            });

            const darkMetalMaterial = new THREE.MeshStandardMaterial({
                color: 0x444455,
                roughness: 0.5,
                metalness: 0.5
            });

            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x665544,
                roughness: 0.9,
                metalness: 0.1
            });

            // Trailer exterior shell
            const shellGeometry = new THREE.BoxGeometry(trailerWidth + 0.2, trailerHeight + 0.2, trailerLength);
            const shellMaterial = new THREE.MeshStandardMaterial({
                color: 0xeeeeee,
                roughness: 0.35,
                metalness: 0.2,
                transparent: true,
                opacity: 0.22,
                depthWrite: false
            });
            const shell = new THREE.Mesh(shellGeometry, shellMaterial);
            shell.position.set(0, trailerHeight / 2 + 0.8, -trailerLength / 2 + 2);
            shell.castShadow = true;
            targetGroup.add(shell);

            // Exterior skin for the trailer (semi-transparent so we still see packages)
            const skinGeometry = new THREE.BoxGeometry(trailerWidth + 0.05, trailerHeight + 0.05, trailerLength - 0.2);
            const skinMaterial = new THREE.MeshStandardMaterial({
                color: 0xf4f4f4,
                roughness: 0.4,
                metalness: 0.2,
                transparent: true,
                opacity: 0.35
            });
            const trailerSkin = new THREE.Mesh(skinGeometry, skinMaterial);
            trailerSkin.position.set(0, trailerHeight / 2 + 0.82, -trailerLength / 2 + 1.9);
            trailerSkin.castShadow = true;
            targetGroup.add(trailerSkin);

            // Interior floor (wooden planks)
            const floorGeometry = new THREE.BoxGeometry(trailerWidth - 0.1, 0.1, trailerLength - 0.2);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.position.set(0, 0.85, -trailerLength / 2 + 2);
            floor.receiveShadow = true;
            targetGroup.add(floor);

            // Floor planks detail
            for (let i = 0; i < 20; i++) {
                const plankLine = new THREE.Mesh(
                    new THREE.BoxGeometry(trailerWidth - 0.1, 0.11, 0.02),
                    darkMetalMaterial
                );
                plankLine.position.set(0, 0.86, 1.5 - i * 0.5);
                targetGroup.add(plankLine);
            }

            // Interior walls with corrugated metal effect (ribs)
            const ribCount = 15;
            const ribSpacing = trailerLength / ribCount;

            // Left wall ribs
            for (let i = 0; i < ribCount; i++) {
                const rib = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, trailerHeight - 0.3, 0.15),
                    metalMaterial
                );
                rib.position.set(-trailerWidth / 2 + 0.1, trailerHeight / 2 + 0.85, 1.8 - i * ribSpacing);
                targetGroup.add(rib);
            }

            // Right wall ribs
            for (let i = 0; i < ribCount; i++) {
                const rib = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, trailerHeight - 0.3, 0.15),
                    metalMaterial
                );
                rib.position.set(trailerWidth / 2 - 0.1, trailerHeight / 2 + 0.85, 1.8 - i * ribSpacing);
                targetGroup.add(rib);
            }

            // Ceiling ribs
            for (let i = 0; i < ribCount; i++) {
                const rib = new THREE.Mesh(
                    new THREE.BoxGeometry(trailerWidth - 0.3, 0.08, 0.15),
                    metalMaterial
                );
                rib.position.set(0, trailerHeight + 0.7, 1.8 - i * ribSpacing);
                targetGroup.add(rib);
            }

            // Back wall (inside)
            const backWallGeometry = new THREE.BoxGeometry(trailerWidth - 0.2, trailerHeight - 0.2, 0.1);
            const backWall = new THREE.Mesh(backWallGeometry, metalMaterial);
            backWall.position.set(0, trailerHeight / 2 + 0.85, -trailerLength + 2.5);
            targetGroup.add(backWall);

            // Interior lighting (LED strips)
            const ledGeometry = new THREE.BoxGeometry(0.05, 0.05, trailerLength - 1);
            const ledMaterial = new THREE.MeshBasicMaterial({ color: 0xffffee });

            const ledLeft = new THREE.Mesh(ledGeometry, ledMaterial);
            ledLeft.position.set(-trailerWidth / 2 + 0.2, trailerHeight + 0.5, -trailerLength / 2 + 2);
            targetGroup.add(ledLeft);

            const ledRight = new THREE.Mesh(ledGeometry, ledMaterial);
            ledRight.position.set(trailerWidth / 2 - 0.2, trailerHeight + 0.5, -trailerLength / 2 + 2);
            targetGroup.add(ledRight);

            // Interior lights
            const interiorLight1 = new THREE.PointLight(0xffffdd, 0.9, 12);
            interiorLight1.position.set(0, trailerHeight + 0.3, -2);
            targetGroup.add(interiorLight1);

            const interiorLight2 = new THREE.PointLight(0xffffdd, 0.6, 10);
            interiorLight2.position.set(0, trailerHeight + 0.3, -5);
            targetGroup.add(interiorLight2);

            // Tie-down rails on floor
            const railGeometry = new THREE.BoxGeometry(0.1, 0.05, trailerLength - 0.5);
            const railMaterial = new THREE.MeshStandardMaterial({
                color: 0x666677,
                roughness: 0.3,
                metalness: 0.8
            });

            const railLeft = new THREE.Mesh(railGeometry, railMaterial);
            railLeft.position.set(-trailerWidth / 2 + 0.3, 0.92, -trailerLength / 2 + 2);
            targetGroup.add(railLeft);

            const railRight = new THREE.Mesh(railGeometry, railMaterial);
            railRight.position.set(trailerWidth / 2 - 0.3, 0.92, -trailerLength / 2 + 2);
            targetGroup.add(railRight);

            // E-Track vertical rails on walls
            for (let z = 0; z < 4; z++) {
                const eTrack = new THREE.Mesh(
                    new THREE.BoxGeometry(0.05, trailerHeight - 0.5, 0.08),
                    railMaterial
                );
                eTrack.position.set(-trailerWidth / 2 + 0.15, trailerHeight / 2 + 0.85, 0 - z * 2);
                targetGroup.add(eTrack);

                const eTrackR = eTrack.clone();
                eTrackR.position.x = trailerWidth / 2 - 0.15;
                targetGroup.add(eTrackR);
            }

            // Door frame (open position)
            const frameThickness = 0.15;
            const frameMaterial = new THREE.MeshStandardMaterial({
                color: 0xff6633,
                roughness: 0.5,
                metalness: 0.3,
                emissive: 0xff3300,
                emissiveIntensity: 0.1
            });

            // Top frame
            const topFrame = new THREE.Mesh(
                new THREE.BoxGeometry(trailerWidth + 0.4, frameThickness, frameThickness),
                frameMaterial
            );
            topFrame.position.set(0, trailerHeight + 0.85, 2.1);
            targetGroup.add(topFrame);

            // Side frames
            const sideFrame = new THREE.Mesh(
                new THREE.BoxGeometry(frameThickness, trailerHeight + 0.1, frameThickness),
                frameMaterial
            );
            sideFrame.position.set(-trailerWidth / 2 - 0.1, trailerHeight / 2 + 0.8, 2.1);
            targetGroup.add(sideFrame);

            const sideFrameR = sideFrame.clone();
            sideFrameR.position.x = trailerWidth / 2 + 0.1;
            targetGroup.add(sideFrameR);

            // Bottom frame
            const bottomFrame = new THREE.Mesh(
                new THREE.BoxGeometry(trailerWidth + 0.4, frameThickness, frameThickness),
                frameMaterial
            );
            bottomFrame.position.set(0, 0.8, 2.1);
            targetGroup.add(bottomFrame);
        }

        function addTrailerInteriorLights(targetGroup) {
            const { height: trailerHeight } = trailerDimensions;
            const interiorLight1 = new THREE.PointLight(0xffffdd, 0.9, 12);
            interiorLight1.position.set(0, trailerHeight + 0.3, -2);
            targetGroup.add(interiorLight1);

            const interiorLight2 = new THREE.PointLight(0xffffdd, 0.6, 10);
            interiorLight2.position.set(0, trailerHeight + 0.3, -5);
            targetGroup.add(interiorLight2);
        }

        function clearTruckContents() {
            while (truck.children.length > 0) {
                truck.remove(truck.children[0]);
            }
        }

        function applyTrailerModel(trailerModel) {
            trailerModel.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            trailerModel.updateWorldMatrix(true, true);
            const boundingBox = new THREE.Box3().setFromObject(trailerModel);
            const size = new THREE.Vector3();
            boundingBox.getSize(size);

            if (size.x && size.y && size.z) {
                const targetSize = new THREE.Vector3(
                    trailerDimensions.width,
                    trailerDimensions.height,
                    trailerDimensions.length
                );
                const scale = Math.min(
                    targetSize.x / size.x,
                    targetSize.y / size.y,
                    targetSize.z / size.z
                );
                trailerModel.scale.setScalar(scale);

                boundingBox.setFromObject(trailerModel);
                const center = new THREE.Vector3();
                boundingBox.getCenter(center);
                trailerModel.position.sub(center);
            } else {
                console.warn('Trailer model has invalid bounds, using default placement.');
            }

            trailerModel.position.y += trailerDimensions.height / 2 + 0.8;
            trailerModel.position.z += -trailerDimensions.length / 2 + 2;

            clearTruckContents();
            truck.add(trailerModel);
            addTrailerInteriorLights(truck);
        }

        function useProceduralTrailer() {
            clearTruckContents();
            buildProceduralTrailer(truck);
        }

        function loadTrailerFromUrl(url) {
            // Check if running from file:// protocol (CORS will block local file loading)
            if (window.location.protocol === 'file:') {
                console.warn('Running from file:// protocol - GLB loading blocked by CORS. Using procedural trailer.');
                console.info('Tip: Use a local server (e.g., "python -m http.server" or "npx serve") to load 3D models.');
                useProceduralTrailer();
                return;
            }

            if (!THREE.GLTFLoader) {
                console.warn('GLTFLoader missing, using procedural trailer.');
                useProceduralTrailer();
                return;
            }

            if (!url) {
                useProceduralTrailer();
                return;
            }

            console.log('Loading trailer model from:', url);
            const loader = new THREE.GLTFLoader();
            loader.load(
                url,
                (gltf) => {
                    try {
                        console.log('Trailer model loaded successfully');
                        applyTrailerModel(gltf.scene);
                    } catch (error) {
                        console.warn('Failed to initialize trailer model, using procedural trailer.', error);
                        useProceduralTrailer();
                    }
                },
                (progress) => {
                    if (progress.total > 0) {
                        console.log('Loading trailer model:', Math.round((progress.loaded / progress.total) * 100) + '%');
                    }
                },
                (error) => {
                    console.warn('Failed to load trailer model, using procedural trailer.', error);
                    useProceduralTrailer();
                }
            );
        }

        // Create the truck/trailer - realistic semi-trailer interior
        function createTruck() {
            truck = new THREE.Group();
            scene.add(truck);

            if (!trailerModelUrl) {
                useProceduralTrailer();
                return;
            }

            loadTrailerFromUrl(trailerModelUrl);
        }

        // Initialize Cannon.js physics
        function initPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            // Ground plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            world.addBody(groundBody);

            // Truck interior colliders
            const { width: trailerWidth, height: trailerHeight, length: trailerLength } = trailerDimensions;

            // Floor
            const floorShape = new CANNON.Box(new CANNON.Vec3(trailerWidth / 2, 0.05, trailerLength / 2));
            const floorBody = new CANNON.Body({ mass: 0 });
            floorBody.addShape(floorShape);
            floorBody.position.set(0, 0.85, -trailerLength / 2 + 2);
            world.addBody(floorBody);

            // Back wall
            const backWallShape = new CANNON.Box(new CANNON.Vec3(trailerWidth / 2, trailerHeight / 2, 0.1));
            const backWallBody = new CANNON.Body({ mass: 0 });
            backWallBody.addShape(backWallShape);
            backWallBody.position.set(0, trailerHeight / 2 + 0.85, -trailerLength + 2.5);
            world.addBody(backWallBody);

            // Side walls
            const sideWallShape = new CANNON.Box(new CANNON.Vec3(0.1, trailerHeight / 2, trailerLength / 2));

            const leftWallBody = new CANNON.Body({ mass: 0 });
            leftWallBody.addShape(sideWallShape);
            leftWallBody.position.set(-trailerWidth / 2, trailerHeight / 2 + 0.85, -trailerLength / 2 + 2);
            world.addBody(leftWallBody);

            const rightWallBody = new CANNON.Body({ mass: 0 });
            rightWallBody.addShape(sideWallShape);
            rightWallBody.position.set(trailerWidth / 2, trailerHeight / 2 + 0.85, -trailerLength / 2 + 2);
            world.addBody(rightWallBody);

            // Ceiling
            const ceilingShape = new CANNON.Box(new CANNON.Vec3(trailerWidth / 2, 0.1, trailerLength / 2));
            const ceilingBody = new CANNON.Body({ mass: 0 });
            ceilingBody.addShape(ceilingShape);
            ceilingBody.position.set(0, trailerHeight + 0.85, -trailerLength / 2 + 2);
            world.addBody(ceilingBody);

        }

        // Initialize audio
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            gainNode.gain.value = 0.3;
        }

        function updateTrackStatus(name, active = false) {
            elements.trackStatus.textContent = name;
            elements.trackStatus.style.color = active ? '#00ff88' : '#fff';
        }

        function ensureUserTrackElement() {
            if (!audioContext) {
                initAudio();
            }

            if (!userTrack) {
                userTrack = new Audio();
                userTrack.preload = 'auto';
                userTrack.loop = false;
                userTrack.addEventListener('ended', () => {
                    useUserTrack = false;
                    updateTrackStatus('Terminée', false);
                    if (gameState.isPlaying) {
                        gameTime = gameDuration;
                        endGame();
                    }
                });
            }
        }

        function setupUserTrack(file) {
            ensureUserTrackElement();

            const url = URL.createObjectURL(file);
            userTrack.src = url;
            userTrack.load();

            userTrack.addEventListener('canplaythrough', () => {
                if (!analyserNode) {
                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 1024;
                    analyserNode.smoothingTimeConstant = 0.85;
                }

                if (!userTrackSource) {
                    userTrackSource = audioContext.createMediaElementSource(userTrack);
                    userTrackSource.connect(analyserNode);
                    analyserNode.connect(gainNode);
                }

                useUserTrack = true;
                updateTrackStatus(file.name, true);
                updateGameDuration();
            }, { once: true });
        }

        function setupUserTrackFromUrl(url, label) {
            ensureUserTrackElement();
            userTrack.src = url;
            userTrack.load();

            userTrack.addEventListener('canplaythrough', () => {
                if (!analyserNode) {
                    analyserNode = audioContext.createAnalyser();
                    analyserNode.fftSize = 1024;
                    analyserNode.smoothingTimeConstant = 0.85;
                }

                if (!userTrackSource) {
                    userTrackSource = audioContext.createMediaElementSource(userTrack);
                    userTrackSource.connect(analyserNode);
                    analyserNode.connect(gainNode);
                }

                useUserTrack = true;
                updateTrackStatus(label, true);
            }, { once: true });
        }

        function clearUserTrack() {
            useUserTrack = false;
            pauseUserTrack();
            if (userTrack) {
                userTrack.src = '';
            }
        }

        function handleMusicUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            lastUploadedTrackName = file.name;
            elements.trackSelect.value = 'upload';
            setupUserTrack(file);
            loadAnalysisBuffer(file).then((loaded) => {
                if (loaded) {
                    analyzeCurrentTrack({ auto: true });
                }
            });
        }

        function updateAnalysisMessage(message, isError = false) {
            elements.analysisMessage.textContent = message;
            elements.analysisMessage.style.color = isError ? '#ff6b6b' : '#ddd';
        }

        function updateAnalysisProgress(percent) {
            if (!elements.analysisProgress || !elements.analysisProgressFill) return;
            const clamped = Math.max(0, Math.min(100, percent));
            elements.analysisProgressFill.style.width = `${clamped}%`;
        }

        function setAnalysisBusy(isBusy) {
            analysisInProgress = isBusy;
            elements.analyzeBtn.disabled = isBusy || !analysisBuffer;
            elements.exportBtn.disabled = isBusy || analysisResults.notes.length === 0;
            if (elements.analysisProgress) {
                elements.analysisProgress.classList.toggle('active', isBusy);
                if (!isBusy) {
                    updateAnalysisProgress(0);
                }
            }
        }

        async function loadAnalysisBuffer(file) {
            if (!audioContext) {
                initAudio();
            }
            elements.exportBtn.disabled = true;
            elements.analysisBpm.textContent = '--';
            elements.analysisNotes.textContent = '0';
            elements.analysisOffset.textContent = '--';
            updateAnalysisMessage('Chargement du fichier audio...');
            setAnalysisBusy(true);
            updateAnalysisProgress(10);

            try {
                await new Promise((resolve) => setTimeout(resolve, 0));
                const arrayBuffer = await file.arrayBuffer();
                updateAnalysisProgress(45);
                analysisBuffer = await audioContext.decodeAudioData(arrayBuffer);
                updateAnalysisProgress(80);
                analysisResults = {
                    bpm: 0,
                    offset: 0,
                    notes: [],
                    onsets: [],
                    subdivision: 4
                };
                analysisBuffer.fileName = file.name;
                updateAnalysisMessage('Fichier prêt pour analyse.');
                updateAnalysisProgress(100);
                return true;
            } catch (error) {
                analysisBuffer = null;
                updateAnalysisMessage('Impossible de décoder ce fichier audio.', true);
                return false;
            } finally {
                setAnalysisBusy(false);
                if (!analysisBuffer && pendingTrackPlayback && gameState.isPlaying && useUserTrack && userTrack && userTrack.paused) {
                    playUserTrack(true);
                    pendingTrackPlayback = false;
                }
            }
        }

        async function loadAnalysisBufferFromUrl(url, name) {
            if (!audioContext) {
                initAudio();
            }
            elements.exportBtn.disabled = true;
            elements.analysisBpm.textContent = '--';
            elements.analysisNotes.textContent = '0';
            elements.analysisOffset.textContent = '--';
            updateAnalysisMessage('Chargement du fichier audio...');
            setAnalysisBusy(true);
            updateAnalysisProgress(10);

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error('Bad response');
                }
                const arrayBuffer = await response.arrayBuffer();
                updateAnalysisProgress(45);
                analysisBuffer = await audioContext.decodeAudioData(arrayBuffer);
                updateAnalysisProgress(80);
                analysisResults = {
                    bpm: 0,
                    offset: 0,
                    notes: [],
                    onsets: [],
                    subdivision: 4
                };
                analysisBuffer.fileName = name;
                updateAnalysisMessage('Fichier prêt pour analyse.');
                updateAnalysisProgress(100);
                return true;
            } catch (error) {
                analysisBuffer = null;
                updateAnalysisMessage('Impossible de décoder ce fichier audio.', true);
                return false;
            } finally {
                setAnalysisBusy(false);
                if (!analysisBuffer && pendingTrackPlayback && gameState.isPlaying && useUserTrack && userTrack && userTrack.paused) {
                    playUserTrack(true);
                    pendingTrackPlayback = false;
                }
            }
        }

        function applyTrackSelection(selection, { persist = true } = {}) {
            if (persist) {
                localStorage.setItem('atomic-parcel-track', selection);
            }

            if (selection === 'none') {
                clearUserTrack();
                updateTrackStatus('Aucune', false);
                return;
            }

            if (selection === 'upload') {
                if (lastUploadedTrackName && userTrack) {
                    useUserTrack = true;
                    updateTrackStatus(lastUploadedTrackName, true);
                } else {
                    useUserTrack = false;
                    updateTrackStatus('Importez une piste', false);
                }
                return;
            }

            const track = defaultTracks[selection];
            if (!track) return;

            setupUserTrackFromUrl(track.url, track.name);
            loadAnalysisBufferFromUrl(track.url, track.name).then((loaded) => {
                if (loaded) {
                    analyzeCurrentTrack({ auto: true });
                }
            });
        }

        function handleAnalysisUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            loadAnalysisBuffer(file);
        }

        function applyHannWindow(buffer, offset, size) {
            const windowed = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                const sample = buffer[offset + i] || 0;
                const multiplier = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (size - 1)));
                windowed[i] = sample * multiplier;
            }
            return windowed;
        }

        function fft(real, imag) {
            const n = real.length;
            const logN = Math.log2(n);
            for (let i = 0; i < n; i++) {
                const j = reverseBits(i, logN);
                if (j > i) {
                    [real[i], real[j]] = [real[j], real[i]];
                    [imag[i], imag[j]] = [imag[j], imag[i]];
                }
            }
            for (let size = 2; size <= n; size *= 2) {
                const halfSize = size / 2;
                const tableStep = Math.PI * 2 / size;
                for (let i = 0; i < n; i += size) {
                    for (let j = 0; j < halfSize; j++) {
                        const angle = tableStep * j;
                        const wr = Math.cos(angle);
                        const wi = -Math.sin(angle);
                        const k = i + j;
                        const l = k + halfSize;
                        const tr = wr * real[l] - wi * imag[l];
                        const ti = wr * imag[l] + wi * real[l];
                        real[l] = real[k] - tr;
                        imag[l] = imag[k] - ti;
                        real[k] += tr;
                        imag[k] += ti;
                    }
                }
            }
        }

        function reverseBits(x, bits) {
            let y = 0;
            for (let i = 0; i < bits; i++) {
                y = (y << 1) | (x & 1);
                x >>= 1;
            }
            return y;
        }

        function detectOnsets(audioBuffer) {
            const sampleRate = audioBuffer.sampleRate;
            const channelData = audioBuffer.numberOfChannels === 1
                ? audioBuffer.getChannelData(0)
                : mixToMono(audioBuffer);
            const fftSize = 2048;
            const hopSize = 512;
            const frameCount = Math.floor((channelData.length - fftSize) / hopSize);
            const prevMag = new Float32Array(fftSize / 2);
            const flux = [];

            for (let frame = 0; frame < frameCount; frame++) {
                const offset = frame * hopSize;
                const windowed = applyHannWindow(channelData, offset, fftSize);
                const real = Array.from(windowed);
                const imag = new Array(fftSize).fill(0);
                fft(real, imag);

                let sum = 0;
                for (let i = 0; i < fftSize / 2; i++) {
                    const mag = Math.hypot(real[i], imag[i]);
                    const diff = mag - prevMag[i];
                    if (diff > 0) {
                        sum += diff;
                    }
                    prevMag[i] = mag;
                }
                flux.push(sum);
            }

            const windowSize = 16;
            const onsets = [];
            for (let i = 1; i < flux.length - 1; i++) {
                const start = Math.max(0, i - windowSize);
                const end = Math.min(flux.length, i + windowSize);
                let mean = 0;
                for (let j = start; j < end; j++) {
                    mean += flux[j];
                }
                mean /= (end - start);
                const threshold = mean * 1.5;
                if (flux[i] > threshold && flux[i] > flux[i - 1] && flux[i] > flux[i + 1]) {
                    const time = (i * hopSize) / sampleRate;
                    onsets.push(time);
                }
            }
            return onsets;
        }

        function mixToMono(buffer) {
            const length = buffer.length;
            const data = new Float32Array(length);
            for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                const channel = buffer.getChannelData(ch);
                for (let i = 0; i < length; i++) {
                    data[i] += channel[i] / buffer.numberOfChannels;
                }
            }
            return data;
        }

        function estimateBpm(onsets) {
            if (onsets.length < 2) return 120;
            const histogram = new Map();
            for (let i = 1; i < onsets.length; i++) {
                const interval = onsets[i] - onsets[i - 1];
                if (interval <= 0.05) continue;
                let bpm = 60 / interval;
                while (bpm < 60) bpm *= 2;
                while (bpm > 180) bpm /= 2;
                const rounded = Math.round(bpm);
                histogram.set(rounded, (histogram.get(rounded) || 0) + 1);
            }
            let bestBpm = 120;
            let bestCount = 0;
            histogram.forEach((count, bpm) => {
                if (count > bestCount) {
                    bestCount = count;
                    bestBpm = bpm;
                }
            });
            return bestBpm;
        }

        function quantizeOnsets(onsets, bpm, subdivision = 4) {
            const beatInterval = 60 / bpm;
            const gridInterval = beatInterval / subdivision;
            const offset = onsets.length ? onsets[0] : 0;
            const quantized = new Map();
            onsets.forEach((time) => {
                const q = Math.round((time - offset) / gridInterval) * gridInterval + offset;
                if (q < 0) return;
                const key = Math.round(q * 1000);
                quantized.set(key, q);
            });
            const times = Array.from(quantized.values()).sort((a, b) => a - b);
            return { times, offset, gridInterval };
        }

        function assignLanes(times, gridInterval) {
            const lanes = ['cube', 'sphere', 'pizza'];
            const lastLaneTime = {
                cube: -Infinity,
                sphere: -Infinity,
                pizza: -Infinity
            };
            let laneIndex = 0;
            const minLaneGap = gridInterval * 0.75;
            const notes = [];

            times.forEach((time) => {
                let chosenLane = null;
                for (let i = 0; i < lanes.length; i++) {
                    const lane = lanes[(laneIndex + i) % lanes.length];
                    if (time - lastLaneTime[lane] >= minLaneGap) {
                        chosenLane = lane;
                        laneIndex = (laneIndex + i + 1) % lanes.length;
                        break;
                    }
                }
                if (!chosenLane) {
                    chosenLane = lanes[laneIndex % lanes.length];
                    laneIndex = (laneIndex + 1) % lanes.length;
                }
                lastLaneTime[chosenLane] = time;
                notes.push({
                    time: Number(time.toFixed(3)),
                    lane: chosenLane
                });
            });
            return notes;
        }

        async function analyzeCurrentTrack({ auto = false } = {}) {
            if (!analysisBuffer) {
                updateAnalysisMessage('Importez une musique avant de lancer l\'analyse.', true);
                return;
            }
            setAnalysisBusy(true);
            updateAnalysisMessage(auto ? 'Analyse automatique en cours... cela peut prendre quelques secondes.' : 'Analyse en cours... cela peut prendre quelques secondes.');
            updateAnalysisProgress(5);
            await new Promise((resolve) => setTimeout(resolve, 50));
            try {
                const onsets = detectOnsets(analysisBuffer);
                updateAnalysisProgress(55);
                const bpm = estimateBpm(onsets);
                const { times, offset, gridInterval } = quantizeOnsets(onsets, bpm, analysisResults.subdivision);
                updateAnalysisProgress(75);
                const notes = assignLanes(times, gridInterval);
                updateAnalysisProgress(90);

                analysisResults = {
                    bpm,
                    offset,
                    notes,
                    onsets,
                    subdivision: analysisResults.subdivision
                };

                elements.analysisBpm.textContent = bpm.toString();
                elements.analysisNotes.textContent = notes.length.toString();
                elements.analysisOffset.textContent = `${offset.toFixed(2)}s`;
                elements.exportBtn.disabled = notes.length === 0;
                updateAnalysisMessage(`Analyse terminée : ${notes.length} notes quantifiées.`);
                updateAnalysisProgress(100);
            } catch (error) {
                updateAnalysisMessage('Analyse impossible. Réessayez avec un autre fichier.', true);
            } finally {
                setAnalysisBusy(false);

                if (pendingTrackPlayback && gameState.isPlaying && useUserTrack && userTrack && userTrack.paused) {
                    playUserTrack(true);
                }
                pendingTrackPlayback = false;
            }
        }

        function exportAnalysisJson() {
            if (!analysisResults.notes.length) return;
            const payload = {
                title: analysisBuffer?.fileName || 'piste',
                bpm: analysisResults.bpm,
                offset: Number(analysisResults.offset.toFixed(3)),
                subdivision: analysisResults.subdivision,
                notes: analysisResults.notes
            };
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${payload.title.replace(/\.[^/.]+$/, '') || 'map'}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function playUserTrack(reset = false) {
            if (!userTrack || !useUserTrack) return;
            if (reset) {
                userTrack.currentTime = 0;
            }
            userTrack.play();
        }

        function pauseUserTrack() {
            if (userTrack && !userTrack.paused) {
                userTrack.pause();
            }
        }

        // Play a beat sound
        function playBeatSound(frequency = 200, type = 'sine', duration = 0.1) {
            if (!audioContext) return;

            const osc = audioContext.createOscillator();
            const oscGain = audioContext.createGain();

            osc.type = type;
            osc.frequency.value = frequency;

            oscGain.gain.setValueAtTime(0.3, audioContext.currentTime);
            oscGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            osc.connect(oscGain);
            oscGain.connect(gainNode);

            osc.start();
            osc.stop(audioContext.currentTime + duration);
        }

        // Play ultimate sound
        function playUltimateSound() {
            if (!audioContext) return;

            // Epic chord
            [200, 300, 400, 500].forEach((freq, i) => {
                setTimeout(() => playBeatSound(freq, 'sine', 0.5), i * 50);
            });
        }

        // Play background beat
        function playBackgroundBeat() {
            if (!gameState.isPlaying || gameState.isPaused) return;

            // Kick drum
            playBeatSound(60, 'sine', 0.15);

            // Schedule hi-hat
            setTimeout(() => {
                if (gameState.isPlaying && !gameState.isPaused) {
                    playBeatSound(800, 'square', 0.05);
                }
            }, gameState.beatInterval / 2);
        }

        let fragileLabelTexture = null;

        function getFragileLabelTexture() {
            if (fragileLabelTexture) return fragileLabelTexture;
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#f7e6d0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 10;
            ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);
            ctx.fillStyle = '#cc0000';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('FRAGILE', canvas.width / 2, canvas.height / 2);
            fragileLabelTexture = new THREE.CanvasTexture(canvas);
            fragileLabelTexture.needsUpdate = true;
            return fragileLabelTexture;
        }

        // Create a package mesh
        function createPackageMesh(type) {
            let geometry, material;
            const group = new THREE.Group();

            // Scale based on combo power
            const scale = 1 + (gameState.comboPower - 1) * 0.3;

            switch(type) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(0.5 * scale, 0.5 * scale, 0.5 * scale);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x4a90d9,
                        roughness: 0.4,
                        metalness: 0.1
                    });
                    const cube = new THREE.Mesh(geometry, material);
                    cube.castShadow = true;
                    group.add(cube);

                    // Add tape lines
                    const tapeMaterial = new THREE.MeshBasicMaterial({ color: 0x8b7355 });
                    const tape1 = new THREE.Mesh(
                        new THREE.BoxGeometry(0.52 * scale, 0.05 * scale, 0.1 * scale),
                        tapeMaterial
                    );
                    tape1.position.y = 0.25 * scale;
                    group.add(tape1);
                    break;

                case 'sphere':
                    geometry = new THREE.SphereGeometry(0.3 * scale, 16, 16);
                    material = new THREE.MeshStandardMaterial({
                        color: 0xd94a4a,
                        roughness: 0.3,
                        metalness: 0.2
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.castShadow = true;
                    group.add(sphere);

                    // Add bubble wrap look
                    const wrapGeometry = new THREE.SphereGeometry(0.32 * scale, 8, 8);
                    const wrapMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.3
                    });
                    group.add(new THREE.Mesh(wrapGeometry, wrapMaterial));
                    break;

                case 'pizza':
                    // Flat box for pizza
                    geometry = new THREE.BoxGeometry(0.7 * scale, 0.15 * scale, 0.7 * scale);
                    material = new THREE.MeshStandardMaterial({
                        color: 0xd9a54a,
                        roughness: 0.8
                    });
                    const pizzaBox = new THREE.Mesh(geometry, material);
                    pizzaBox.castShadow = true;
                    group.add(pizzaBox);

                    // Add "PIZZA" indication on top
                    const topGeometry = new THREE.CircleGeometry(0.25 * scale, 8);
                    const topMaterial = new THREE.MeshBasicMaterial({ color: 0xcc0000 });
                    const top = new THREE.Mesh(topGeometry, topMaterial);
                    top.rotation.x = -Math.PI / 2;
                    top.position.y = 0.08 * scale;
                    group.add(top);
                    break;

                case 'cereal':
                    geometry = new THREE.BoxGeometry(0.35 * scale, 0.7 * scale, 0.2 * scale);
                    material = new THREE.MeshStandardMaterial({
                        color: 0xffcc66,
                        roughness: 0.7,
                        metalness: 0.1
                    });
                    const cerealBox = new THREE.Mesh(geometry, material);
                    cerealBox.castShadow = true;
                    group.add(cerealBox);
                    const cerealLabel = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.3 * scale, 0.55 * scale),
                        new THREE.MeshBasicMaterial({ color: 0xff6699 })
                    );
                    cerealLabel.position.z = 0.11 * scale;
                    cerealLabel.position.y = 0.05 * scale;
                    group.add(cerealLabel);
                    break;

                case 'plant':
                    geometry = new THREE.CylinderGeometry(0.18 * scale, 0.25 * scale, 0.35 * scale, 16);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x7a4a2b,
                        roughness: 0.8
                    });
                    const pot = new THREE.Mesh(geometry, material);
                    pot.castShadow = true;
                    group.add(pot);
                    const leafMaterial = new THREE.MeshStandardMaterial({
                        color: 0x33aa55,
                        roughness: 0.6
                    });
                    for (let i = 0; i < 6; i++) {
                        const leaf = new THREE.Mesh(
                            new THREE.ConeGeometry(0.1 * scale, 0.4 * scale, 6),
                            leafMaterial
                        );
                        leaf.position.y = 0.3 * scale;
                        leaf.rotation.z = (Math.PI / 3) * i;
                        leaf.rotation.x = Math.PI / 2;
                        group.add(leaf);
                    }
                    break;

                case 'suitcase':
                    geometry = new THREE.BoxGeometry(0.55 * scale, 0.35 * scale, 0.25 * scale);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x3f4c6b,
                        roughness: 0.4,
                        metalness: 0.3
                    });
                    const suitcase = new THREE.Mesh(geometry, material);
                    suitcase.castShadow = true;
                    group.add(suitcase);
                    const handle = new THREE.Mesh(
                        new THREE.BoxGeometry(0.2 * scale, 0.05 * scale, 0.05 * scale),
                        new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 })
                    );
                    handle.position.y = 0.23 * scale;
                    group.add(handle);
                    break;

                case 'duffel':
                    geometry = new THREE.CylinderGeometry(0.25 * scale, 0.25 * scale, 0.5 * scale, 18);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x2f6f6f,
                        roughness: 0.5
                    });
                    const duffel = new THREE.Mesh(geometry, material);
                    duffel.rotation.z = Math.PI / 2;
                    duffel.castShadow = true;
                    group.add(duffel);
                    break;

                case 'express':
                    geometry = new THREE.BoxGeometry(0.5 * scale, 0.3 * scale, 0.4 * scale);
                    material = new THREE.MeshStandardMaterial({
                        color: 0x00cc88,
                        roughness: 0.6,
                        metalness: 0.2
                    });
                    const expressBox = new THREE.Mesh(geometry, material);
                    expressBox.castShadow = true;
                    group.add(expressBox);
                    const expressStripe = new THREE.Mesh(
                        new THREE.PlaneGeometry(0.45 * scale, 0.12 * scale),
                        new THREE.MeshBasicMaterial({ color: 0x003322 })
                    );
                    expressStripe.position.z = 0.21 * scale;
                    group.add(expressStripe);
                    break;

                case 'fragile':
                    geometry = new THREE.BoxGeometry(0.9 * scale, 0.6 * scale, 0.9 * scale);
                    material = new THREE.MeshStandardMaterial({
                        color: 0xf7e6d0,
                        roughness: 0.6,
                        metalness: 0.1
                    });
                    const fragileBox = new THREE.Mesh(geometry, material);
                    fragileBox.castShadow = true;
                    group.add(fragileBox);

                    const labelTexture = getFragileLabelTexture();
                    const labelMaterial = new THREE.MeshBasicMaterial({
                        map: labelTexture,
                        transparent: true
                    });

                    const labelGeometry = new THREE.PlaneGeometry(0.8 * scale, 0.4 * scale);
                    const topLabel = new THREE.Mesh(labelGeometry, labelMaterial);
                    topLabel.rotation.x = -Math.PI / 2;
                    topLabel.position.y = 0.31 * scale;
                    group.add(topLabel);

                    const sideLabel = new THREE.Mesh(labelGeometry, labelMaterial);
                    sideLabel.position.z = 0.46 * scale;
                    sideLabel.position.y = 0.05 * scale;
                    group.add(sideLabel);
                    break;
            }

            // Add glow effect for high combo
            if (gameState.comboPower >= 2) {
                const glowColor = gameState.comboPower >= 3 ? 0xff0066 : 0xff6600;
                const glowIntensity = (gameState.comboPower - 1) * 0.3;
                group.children[0].material.emissive = new THREE.Color(glowColor);
                group.children[0].material.emissiveIntensity = glowIntensity;
            }

            return group;
        }

        // Create physics body for package
        function createPackageBody(type, position, velocity) {
            let shape, mass = 2;
            const scale = 1 + (gameState.comboPower - 1) * 0.3;

            switch(type) {
                case 'cube':
                    shape = new CANNON.Box(new CANNON.Vec3(0.25 * scale, 0.25 * scale, 0.25 * scale));
                    break;
                case 'sphere':
                    shape = new CANNON.Sphere(0.3 * scale);
                    mass = 1.5;
                    break;
                case 'pizza':
                    shape = new CANNON.Box(new CANNON.Vec3(0.35 * scale, 0.075 * scale, 0.35 * scale));
                    mass = 1;
                    break;
                case 'cereal':
                    shape = new CANNON.Box(new CANNON.Vec3(0.175 * scale, 0.35 * scale, 0.1 * scale));
                    mass = 1.4;
                    break;
                case 'plant':
                    shape = new CANNON.Cylinder(0.2 * scale, 0.25 * scale, 0.35 * scale, 12);
                    mass = 1.6;
                    break;
                case 'suitcase':
                    shape = new CANNON.Box(new CANNON.Vec3(0.275 * scale, 0.175 * scale, 0.125 * scale));
                    mass = 2;
                    break;
                case 'duffel':
                    shape = new CANNON.Cylinder(0.25 * scale, 0.25 * scale, 0.5 * scale, 12);
                    mass = 1.8;
                    break;
                case 'express':
                    shape = new CANNON.Box(new CANNON.Vec3(0.25 * scale, 0.15 * scale, 0.2 * scale));
                    mass = 1.6;
                    break;
                case 'fragile':
                    shape = new CANNON.Box(new CANNON.Vec3(0.45 * scale, 0.3 * scale, 0.45 * scale));
                    mass = 2.5;
                    break;
            }

            // Increase mass with combo power
            mass *= gameState.comboPower;

            const body = new CANNON.Body({ mass: mass });
            body.addShape(shape);
            body.position.copy(position);
            body.velocity.copy(velocity);

            // Add some spin
            const spinMultiplier = gameState.comboPower;
            body.angularVelocity.set(
                (Math.random() - 0.5) * 10 * spinMultiplier,
                (Math.random() - 0.5) * 10 * spinMultiplier,
                (Math.random() - 0.5) * 10 * spinMultiplier
            );

            // Collision detection for breaking - easier to break with high combo
            const breakThreshold = Math.max(4, 10 - gameState.comboPower * 2);

            body.addEventListener('collide', (e) => {
                if (gameState.combo < PACKAGE_BREAK_COMBO_REQUIRED) {
                    return;
                }
                const relVel = e.contact.getImpactVelocityAlongNormal();
                if (Math.abs(relVel) > breakThreshold) {
                    const meshData = packages.find(p => p.body === body);
                    if (meshData && !meshData.broken) {
                        breakPackage(meshData);
                    }
                }
            });

            world.addBody(body);
            return body;
        }

        // Launch a package
        const packageVariants = {
            cube: ['cube', 'cereal', 'cube'],
            sphere: ['sphere', 'plant'],
            pizza: ['pizza', 'suitcase', 'duffel'],
            fragile: ['fragile'],
            express: ['express', 'suitcase', 'plant']
        };

        function selectPackageVariant(type) {
            const variants = packageVariants[type] || [type];
            return variants[Math.floor(Math.random() * variants.length)];
        }

        function launchPackage(type) {
            const variant = selectPackageVariant(type);
            const mesh = createPackageMesh(variant);

            // Start position (from the dock)
            const startPos = new THREE.Vector3(
                (Math.random() - 0.5) * 1,
                2,
                8
            );
            mesh.position.copy(startPos);
            scene.add(mesh);

            // Calculate velocity based on power and combo
            const power = gameState.power;
            const comboPower = gameState.comboPower;
            const baseSpeed = 15 + power * 12 + comboPower * 3;

            // Direction toward truck opening
            const velocity = new CANNON.Vec3(
                (Math.random() - 0.5) * 3,
                4 + power * 5,
                -baseSpeed
            );

            const body = createPackageBody(variant,
                new CANNON.Vec3(startPos.x, startPos.y, startPos.z),
                velocity
            );

            packages.push({
                mesh: mesh,
                body: body,
                type: variant,
                broken: false,
                lifetime: 0,
                breakTime: 0
            });

            // Play throw sound - more intense with combo
            const soundFreq = 150 + power * 100 + comboPower * 50;
            playBeatSound(soundFreq, 'sawtooth', 0.1);
        }

        // Break a package into pieces - EXPLOSION!
        function breakPackage(packageData) {
            if (packageData.broken) return;
            packageData.broken = true;
            packageData.breakTime = packageData.lifetime;

            const pos = packageData.mesh.position.clone();
            const color = packageData.mesh.children[0].material.color.clone();

            // More particles with higher combo
            const particleCount = 15 + gameState.comboPower * 10;
            const explosionForce = 5 + gameState.comboPower * 3;

            // Create particle explosion
            for (let i = 0; i < particleCount; i++) {
                // Varied particle sizes
                const size = 0.05 + Math.random() * 0.15;
                const particleGeometry = new THREE.BoxGeometry(size, size, size);

                // Slight color variation
                const particleColor = color.clone();
                particleColor.offsetHSL(Math.random() * 0.1 - 0.05, 0, Math.random() * 0.2 - 0.1);

                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: particleColor,
                    transparent: true,
                    opacity: 1
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(pos);
                particle.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                ));
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * explosionForce * 2,
                    Math.random() * explosionForce * 1.5,
                    (Math.random() - 0.5) * explosionForce * 2
                );
                particle.rotationSpeed = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                particle.lifetime = 0;
                particle.maxLifetime = 0.8 + Math.random() * 0.4;
                scene.add(particle);
                particles.push(particle);
            }

            // Hide original mesh
            packageData.mesh.visible = false;
            if (packageData.body) {
                world.removeBody(packageData.body);
                packageData.body = null;
            }

            // Update score - more points with combo
            gameState.brokenPackages++;
            const breakPoints = 100 * getEffectiveScoreMultiplier() * gameState.comboPower;
            gameState.score += breakPoints;
            elements.brokenValue.textContent = gameState.brokenPackages;
            updateScoreDisplay();

            // Show feedback
            showFeedback(`BOOM! +${breakPoints}`, 'break', window.innerWidth / 2, window.innerHeight / 2 - 100);

            // Play break sound - more epic with combo
            const basePitch = 100 - gameState.comboPower * 10;
            playBeatSound(basePitch, 'sawtooth', 0.2 + gameState.comboPower * 0.1);
            playBeatSound(basePitch - 20, 'square', 0.3);

            if (gameState.comboPower >= 3) {
                // Extra explosion sounds for high combo
                playBeatSound(50, 'sine', 0.4);
            }
        }

        // Show feedback text
        function showFeedback(text, type, x, y) {
            const feedback = document.createElement('div');
            feedback.className = `feedback-text ${type}`;
            feedback.textContent = text;
            feedback.style.left = x + 'px';
            feedback.style.top = y + 'px';
            elements.container.appendChild(feedback);

            setTimeout(() => feedback.remove(), 1000);
        }

        function applyMissPenalty({ label = 'RATE!', x = window.innerWidth / 2, y = window.innerHeight - 250, playSound = false } = {}) {
            gameState.score = Math.max(0, gameState.score - MISS_SCORE_PENALTY);
            updateScoreDisplay();
            showFeedback(`${label} -${MISS_SCORE_PENALTY}`, 'miss', x, y);
            recordNoteOutcome(false);
            if (playSound) {
                playBeatSound(100, 'square', 0.1);
            }
        }

        function recordNoteOutcome(hit) {
            const now = performance.now();
            gameState.recentNoteResults.push({ time: now, hit });
            pruneRecentNotes(now);
            updatePerformanceIndicator(now);
        }

        function pruneRecentNotes(now = performance.now()) {
            const cutoff = now - PERFORMANCE_WINDOW_MS;
            while (gameState.recentNoteResults.length && gameState.recentNoteResults[0].time < cutoff) {
                gameState.recentNoteResults.shift();
            }
        }

        function getRecentAccuracy(now = performance.now()) {
            pruneRecentNotes(now);
            const total = gameState.recentNoteResults.length;
            if (total === 0) {
                return { accuracy: 1, total };
            }
            const hits = gameState.recentNoteResults.reduce((sum, entry) => sum + (entry.hit ? 1 : 0), 0);
            return { accuracy: hits / total, total };
        }

        function updatePerformanceIndicator(now = performance.now()) {
            const { accuracy, total } = getRecentAccuracy(now);
            const accuracyPercent = Math.round(accuracy * 100);
            elements.performancePercent.textContent = `${accuracyPercent}%`;
            elements.performanceFill.style.width = `${Math.max(0, Math.min(accuracy, 1)) * 100}%`;
            elements.performanceMeter.classList.remove('warning', 'danger');

            if (total >= PERFORMANCE_MIN_NOTES) {
                if (accuracy < PERFORMANCE_REQUIRED_ACCURACY) {
                    elements.performanceMeter.classList.add('danger');
                    elements.performanceStatus.textContent = 'DANGER';
                } else if (accuracy < PERFORMANCE_REQUIRED_ACCURACY + 0.15) {
                    elements.performanceMeter.classList.add('warning');
                    elements.performanceStatus.textContent = 'ALERTE';
                } else {
                    elements.performanceStatus.textContent = 'OK';
                }
            } else {
                elements.performanceStatus.textContent = 'CALIBRAGE';
            }
        }

        function updatePerformanceMeter(deltaTime) {
            const now = performance.now();
            const { accuracy, total } = getRecentAccuracy(now);

            if (total >= PERFORMANCE_MIN_NOTES) {
                if (accuracy < PERFORMANCE_REQUIRED_ACCURACY) {
                    gameState.dangerTimer += deltaTime * 1000;
                } else {
                    gameState.dangerTimer = Math.max(0, gameState.dangerTimer - deltaTime * 1000 * 1.5);
                }
            } else {
                gameState.dangerTimer = Math.max(0, gameState.dangerTimer - deltaTime * 1000);
            }

            updatePerformanceIndicator(now);

            if (gameState.dangerTimer >= PERFORMANCE_DANGER_DURATION) {
                endGame('Rythme trop instable : la tournée est interrompue.');
            }
        }

        // Create a beat note on the rhythm bar
        function getNoteWidth(type) {
            if (type === 'fragile') {
                return FRAGILE_NOTE_WIDTH;
            }
            if (type === 'express') {
                return EXPRESS_NOTE_WIDTH;
            }
            return NOTE_WIDTH;
        }

        function pickNoteType() {
            const fragileChance = 0.1;
            const expressChance = 0.08;
            const roll = Math.random();
            const types = ['cube', 'sphere', 'pizza'];
            if (roll < fragileChance) {
                return 'fragile';
            }
            if (roll < fragileChance + expressChance) {
                return 'express';
            }
            return types[Math.floor(Math.random() * types.length)];
        }

        function createBeatNote(type) {

            const note = document.createElement('div');
            note.className = `beat-note ${type}`;
            note.dataset.id = noteId++;
            note.dataset.type = type;
            note.style.right = '-70px';

            if (type === 'fragile') {
                const cubeKey = getKeyDisplayName(keyBindings.cube);
                const sphereKey = getKeyDisplayName(keyBindings.sphere);
                note.innerHTML = `
                    <span class="fragile-link"></span>
                    <span class="fragile-gem cube">${cubeKey}</span>
                    <span class="fragile-gem sphere">${sphereKey}</span>
                `;
            } else if (type === 'express') {
                const cubeKey = getKeyDisplayName(keyBindings.cube);
                const spaceMarkup = keyBindings.pizza === ' '
                    ? '<span class="spacebar-icon"></span>'
                    : getKeyDisplayName(keyBindings.pizza);
                note.innerHTML = `
                    <span class="express-link"></span>
                    <span class="combo-gem cube">${cubeKey}</span>
                    <span class="combo-gem space">${spaceMarkup}</span>
                `;
            } else {
                if (type === 'pizza' && keyBindings.pizza === ' ') {
                    note.innerHTML = '<span class="spacebar-icon"></span>';
                } else {
                    let keyText = getKeyDisplayName(keyBindings[type]);
                    note.textContent = keyText;
                }
            }

            elements.rhythmBar.appendChild(note);
            beatNotes.push({
                element: note,
                type: type,
                position: -70,
                hit: false
            });

            gameState.totalNotes++;
        }

        let lastNoteSpawnWidth = NOTE_WIDTH;

        function getSpawnSpacingInterval(nextNoteWidth) {
            const requiredSpacing = (lastNoteSpawnWidth / 2) + (nextNoteWidth / 2) + NOTE_SPACING;
            return (requiredSpacing / noteSpeed) * 1000;
        }

        const comboNoteTypes = new Set(['fragile', 'express']);
        let lastComboNoteTime = -Infinity;
        let lastRegularNoteTime = -Infinity;

        function canSpawnNote(now = performance.now(), nextNoteType = 'cube', nextNoteWidth = NOTE_WIDTH) {
            const spacingInterval = getSpawnSpacingInterval(nextNoteWidth);
            while (noteSpawnTimestamps.length && now - noteSpawnTimestamps[0] > 1000) {
                noteSpawnTimestamps.shift();
            }
            if (maxNotesPerSecond > 0 && noteSpawnTimestamps.length >= maxNotesPerSecond) {
                return false;
            }
            if (now - lastNoteSpawnTime < spacingInterval) {
                return false;
            }
            if (comboNoteTypes.has(nextNoteType)) {
                if (now - lastRegularNoteTime < COMBO_NOTE_GAP) {
                    return false;
                }
            } else if (now - lastComboNoteTime < COMBO_NOTE_GAP) {
                return false;
            }
            return true;
        }

        function registerNoteSpawn(now = performance.now(), noteWidth = NOTE_WIDTH, noteType = 'cube') {
            noteSpawnTimestamps.push(now);
            lastNoteSpawnTime = now;
            lastNoteSpawnWidth = noteWidth;
            if (comboNoteTypes.has(noteType)) {
                lastComboNoteTime = now;
            } else {
                lastRegularNoteTime = now;
            }
        }

        function shouldForceSpawn(now = performance.now()) {
            if (minNotesPerSecond <= 0) return false;
            const maxGap = 1000 / minNotesPerSecond;
            return (now - lastNoteSpawnTime) >= maxGap;
        }

        function spawnNoteIfAllowed(now = performance.now()) {
            const nextType = pickNoteType();
            const nextWidth = getNoteWidth(nextType);
            if (canSpawnNote(now, nextType, nextWidth)) {
                createBeatNote(nextType);
                registerNoteSpawn(now, nextWidth, nextType);
                return true;
            }
            return false;
        }

        function detectBeat() {
            if (!analyserNode || !audioContext) return false;

            const freqData = new Uint8Array(analyserNode.frequencyBinCount);
            analyserNode.getByteFrequencyData(freqData);

            let sum = 0;
            const lowBins = 18;
            for (let i = 0; i < lowBins; i++) {
                sum += freqData[i];
            }
            const freqEnergy = sum / lowBins;

            const timeData = new Uint8Array(analyserNode.fftSize);
            analyserNode.getByteTimeDomainData(timeData);
            let rms = 0;
            for (let i = 0; i < timeData.length; i++) {
                const sample = (timeData[i] - 128) / 128;
                rms += sample * sample;
            }
            rms = Math.sqrt(rms / timeData.length);
            const rmsEnergy = rms * 120;

            const energy = freqEnergy * 0.65 + rmsEnergy * 0.35;

            beatDetector.energyHistory.push(energy);
            if (beatDetector.energyHistory.length > beatDetector.historySize) {
                beatDetector.energyHistory.shift();
            }

            const avg = beatDetector.energyHistory.reduce((acc, val) => acc + val, 0) / beatDetector.energyHistory.length;
            const variance = beatDetector.energyHistory.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / beatDetector.energyHistory.length;
            const dynamicThreshold = avg + Math.sqrt(variance) * beatDetector.sensitivity;
            const threshold = Math.max(dynamicThreshold, avg * 1.05 + 6);
            beatDetector.energyAvg = avg;

            const now = audioContext.currentTime;

            if (energy > threshold && (now - beatDetector.lastBeatTime) > beatDetector.minInterval) {
                beatDetector.prevBeatTime = beatDetector.lastBeatTime || now;
                beatDetector.lastBeatTime = now;

                const interval = (beatDetector.lastBeatTime - beatDetector.prevBeatTime) * 1000;
                if (interval > 100) {
                    gameState.beatInterval = interval;
                    gameState.bpm = Math.round(60000 / interval);
                }
                return true;
            }
            return false;
        }

        // Update beat notes positions
        function updateBeatNotes(deltaTime) {
            const speed = noteSpeed;
            const hitZone = 300;
            const okWindow = 120;

            for (let i = beatNotes.length - 1; i >= 0; i--) {
                const note = beatNotes[i];
                if (note.hit) continue;

                note.position += speed * deltaTime;
                note.element.style.right = (-70 + note.position) + 'px';

                // Ultimate mode - auto hit
                if (gameState.ultimateActive) {
                    const distance = Math.abs(note.position - hitZone);
                    if (distance < 30) {
                        autoHitNote(note, i);
                        continue;
                    }
                }

                // Check if note passed without being hit
                if (note.position > hitZone + okWindow + 30) {
                    note.element.remove();
                    beatNotes.splice(i, 1);

                    // Miss!
                    gameState.combo = 0;
                    gameState.perfectStreak = 0;
                    gameState.multiplier = 1;
                    gameState.comboPower = 1;
                    updateComboDisplay();
                    updatePerfectStreak();
                    applyMissPenalty();
                }
            }
        }

        // Auto-hit note during ultimate
        function autoHitNote(note, index) {
            note.hit = true;
            note.element.classList.add('hit');
            gameState.hitNotes++;
            recordNoteOutcome(true);

            // Always perfect during ultimate
            gameState.combo++;
            if (gameState.combo > gameState.maxCombo) {
                gameState.maxCombo = gameState.combo;
            }
            gameState.multiplier = Math.min(8, 1 + Math.floor(gameState.combo / 5));
            gameState.comboPower = Math.min(4, 1 + Math.floor(gameState.combo / 10));

            const points = (note.type === 'express' ? 70 : 50) * getEffectiveScoreMultiplier();
            gameState.score += points;
            updateScoreDisplay();
            updateComboDisplay();
            addUltimateCharge(1);

            showFeedback('AUTO!', 'ultimate', window.innerWidth / 2, window.innerHeight - 250);
            launchPackage(note.type);
            if (note.type === 'fragile') {
                triggerFragileBonus();
            }
            if (note.type === 'express') {
                triggerExpressBonus();
            }
            playBeatSound(600, 'sine', 0.1);

            setTimeout(() => {
                note.element.remove();
                const idx = beatNotes.indexOf(note);
                if (idx > -1) beatNotes.splice(idx, 1);
            }, 300);
        }

        function checkFragileHit() {
            const now = performance.now();
            if (now - lastFragileTrigger < 150) {
                return false;
            }
            lastFragileTrigger = now;

            const hitZone = 300;
            const hitWindow = 50;
            const goodWindow = 80;
            const okWindow = 110;

            for (let i = 0; i < beatNotes.length; i++) {
                const note = beatNotes[i];
                if (note.hit || note.type !== 'fragile') continue;

                const distance = Math.abs(note.position - hitZone);

                if (distance < okWindow) {
                    note.hit = true;
                    note.element.classList.add('hit');
                    gameState.hitNotes++;
                    recordNoteOutcome(true);

                    let points = 0;
                    let feedback = '';
                    let feedbackType = '';
                    let isPerfect = false;

                    if (distance < hitWindow) {
                        points = 70;
                        feedback = 'FRAGILE PARFAIT!';
                        feedbackType = 'perfect';
                        isPerfect = true;
                        playBeatSound(650, 'sine', 0.12);
                    } else if (distance < goodWindow) {
                        points = 40;
                        feedback = 'FRAGILE!';
                        feedbackType = 'good';
                        playBeatSound(450, 'sine', 0.12);
                    } else {
                        points = 20;
                        feedback = 'FRAGILE OK';
                        feedbackType = 'ok';
                        playBeatSound(320, 'sine', 0.12);
                    }

                    gameState.combo++;
                    if (gameState.combo > gameState.maxCombo) {
                        gameState.maxCombo = gameState.combo;
                    }
                    gameState.multiplier = Math.min(8, 1 + Math.floor(gameState.combo / 5));
                    gameState.comboPower = Math.min(4, 1 + Math.floor(gameState.combo / 10));

                    if (isPerfect) {
                        gameState.perfectStreak++;
                    } else {
                        gameState.perfectStreak = 0;
                    }
                    updatePerfectStreak();

                    const totalPoints = points * getEffectiveScoreMultiplier();
                    gameState.score += totalPoints;
                    updateScoreDisplay();
                    updateComboDisplay();
                    addUltimateCharge(1);

                    showFeedback(`${feedback} +${totalPoints}`, feedbackType, window.innerWidth / 2, window.innerHeight - 250);

                    triggerFragileBonus();
                    launchPackage('fragile');

                    setTimeout(() => {
                        note.element.remove();
                        const idx = beatNotes.indexOf(note);
                        if (idx > -1) beatNotes.splice(idx, 1);
                    }, 300);

                    return true;
                }
            }

            return false;
        }

        function checkExpressHit() {
            const now = performance.now();
            if (now - lastFragileTrigger < 150) {
                return false;
            }
            lastFragileTrigger = now;

            const hitZone = 300;
            const hitWindow = 45;
            const goodWindow = 80;
            const okWindow = 115;

            for (let i = 0; i < beatNotes.length; i++) {
                const note = beatNotes[i];
                if (note.hit || note.type !== 'express') continue;

                const distance = Math.abs(note.position - hitZone);

                if (distance < okWindow) {
                    note.hit = true;
                    note.element.classList.add('hit');
                    gameState.hitNotes++;
                    recordNoteOutcome(true);

                    let points = 0;
                    let feedback = '';
                    let feedbackType = '';
                    let isPerfect = false;

                    if (distance < hitWindow) {
                        points = 80;
                        feedback = 'EXPRESS PARFAIT!';
                        feedbackType = 'perfect';
                        isPerfect = true;
                        playBeatSound(700, 'sine', 0.12);
                    } else if (distance < goodWindow) {
                        points = 45;
                        feedback = 'EXPRESS!';
                        feedbackType = 'good';
                        playBeatSound(520, 'sine', 0.12);
                    } else {
                        points = 25;
                        feedback = 'EXPRESS OK';
                        feedbackType = 'ok';
                        playBeatSound(350, 'sine', 0.12);
                    }

                    gameState.combo++;
                    if (gameState.combo > gameState.maxCombo) {
                        gameState.maxCombo = gameState.combo;
                    }
                    gameState.multiplier = Math.min(8, 1 + Math.floor(gameState.combo / 5));
                    gameState.comboPower = Math.min(4, 1 + Math.floor(gameState.combo / 10));

                    if (isPerfect) {
                        gameState.perfectStreak++;
                    } else {
                        gameState.perfectStreak = 0;
                    }
                    updatePerfectStreak();

                    const totalPoints = points * getEffectiveScoreMultiplier();
                    gameState.score += totalPoints;
                    updateScoreDisplay();
                    updateComboDisplay();
                    addUltimateCharge(1);

                    showFeedback(`${feedback} +${totalPoints}`, feedbackType, window.innerWidth / 2, window.innerHeight - 250);

                    triggerExpressBonus();
                    launchPackage('express');

                    setTimeout(() => {
                        note.element.remove();
                        const idx = beatNotes.indexOf(note);
                        if (idx > -1) beatNotes.splice(idx, 1);
                    }, 300);

                    return true;
                }
            }

            return false;
        }

        function hasFragileNoteInWindow() {
            const hitZone = 300;
            const okWindow = 110;
            return beatNotes.some(note => {
                if (note.hit || note.type !== 'fragile') return false;
                return Math.abs(note.position - hitZone) < okWindow;
            });
        }

        function hasExpressNoteInWindow() {
            const hitZone = 300;
            const okWindow = 115;
            return beatNotes.some(note => {
                if (note.hit || note.type !== 'express') return false;
                return Math.abs(note.position - hitZone) < okWindow;
            });
        }

        // Check if a key press hits a note
        function checkNoteHit(type) {
            const hitZone = 300;
            const hitWindow = 40;
            const goodWindow = 70;
            const okWindow = 100;

            for (let i = 0; i < beatNotes.length; i++) {
                const note = beatNotes[i];
                if (note.hit || note.type !== type) continue;

                const distance = Math.abs(note.position - hitZone);

                if (distance < okWindow) {
                    note.hit = true;
                    note.element.classList.add('hit');
                    gameState.hitNotes++;
                    recordNoteOutcome(true);

                    let points = 0;
                    let feedback = '';
                    let feedbackType = '';
                    let isPerfect = false;

                    if (distance < hitWindow) {
                        points = 50;
                        feedback = 'PARFAIT!';
                        feedbackType = 'perfect';
                        isPerfect = true;
                        playBeatSound(600, 'sine', 0.1);
                    } else if (distance < goodWindow) {
                        points = 30;
                        feedback = 'BIEN!';
                        feedbackType = 'good';
                        playBeatSound(400, 'sine', 0.1);
                    } else {
                        points = 10;
                        feedback = 'OK';
                        feedbackType = 'ok';
                        playBeatSound(300, 'sine', 0.1);
                    }

                    // Update combo
                    gameState.combo++;
                    if (gameState.combo > gameState.maxCombo) {
                        gameState.maxCombo = gameState.combo;
                    }

                    // Multiplier (up to 8x)
                    gameState.multiplier = Math.min(8, 1 + Math.floor(gameState.combo / 5));

                    // Combo power for throw strength (up to 4x)
                    gameState.comboPower = Math.min(4, 1 + Math.floor(gameState.combo / 10));

                    // Perfect streak for ultimate
                    if (isPerfect) {
                        gameState.perfectStreak++;
                    } else {
                        gameState.perfectStreak = 0;
                    }
                    updatePerfectStreak();

                    // Add score
                    const totalPoints = points * getEffectiveScoreMultiplier();
                    gameState.score += totalPoints;
                    updateScoreDisplay();
                    updateComboDisplay();
                    addUltimateCharge(1);

                    // Show feedback
                    showFeedback(feedback + ` +${totalPoints}`, feedbackType, window.innerWidth / 2, window.innerHeight - 250);

                    // Launch the package
                    launchPackage(type);

                    setTimeout(() => {
                        note.element.remove();
                        const idx = beatNotes.indexOf(note);
                        if (idx > -1) beatNotes.splice(idx, 1);
                    }, 300);

                    return true;
                }
            }

            return false;
        }

        // Update score display
        function updateScoreDisplay() {
            elements.scoreDisplay.textContent = gameState.score.toLocaleString();
        }

        // Update combo display
        function updateComboDisplay() {
            elements.comboValue.textContent = gameState.combo;
            elements.multValue.textContent = gameState.multiplier;

            // Update combo meter visual
            elements.comboMeter.className = 'combo-meter';
            if (gameState.comboPower >= 4) {
                elements.comboMeter.classList.add('fire-4');
            } else if (gameState.comboPower >= 3) {
                elements.comboMeter.classList.add('fire-3');
            } else if (gameState.comboPower >= 2) {
                elements.comboMeter.classList.add('fire-2');
            } else if (gameState.combo >= 5) {
                elements.comboMeter.classList.add('fire-1');
            }
        }

        // Update perfect streak display
        function updatePerfectStreak() {
            elements.streakValue.textContent = gameState.perfectStreak;
            if (gameState.perfectStreak >= 3) {
                elements.perfectStreak.classList.add('visible');
            } else {
                elements.perfectStreak.classList.remove('visible');
            }
        }

        // Update ultimate bar
        function updateUltimateBar() {
            elements.ultimateFill.style.height = gameState.ultimateCharge + '%';

            if (gameState.ultimateActive) {
                elements.ultimateBar.classList.remove('ready');
                elements.ultimateBar.classList.add('active');
                elements.ultimateKey.classList.remove('visible');
                elements.ultimateOverlay.classList.add('active');
            } else if (gameState.ultimateCharge >= 100) {
                elements.ultimateBar.classList.add('ready');
                elements.ultimateBar.classList.remove('active');
                elements.ultimateKey.classList.add('visible');
                elements.ultimateOverlay.classList.remove('active');
            } else {
                elements.ultimateBar.classList.remove('ready', 'active');
                elements.ultimateKey.classList.remove('visible');
                elements.ultimateOverlay.classList.remove('active');
            }
        }

        function updateFragileMultiplierDisplay() {
            if (gameState.fragileMultiplier > 1) {
                elements.fragileMultiplier.classList.add('active');
                elements.fragileMultiplier.textContent = `FRAGILE x${gameState.fragileMultiplier}`;
            } else {
                elements.fragileMultiplier.classList.remove('active');
            }
        }

        function getEffectiveScoreMultiplier() {
            return gameState.multiplier * gameState.fragileMultiplier;
        }

        function addUltimateCharge(points = 1) {
            if (gameState.ultimateActive) return;
            gameState.ultimateChargePoints = Math.min(
                ULTIMATE_CHARGE_REQUIRED,
                gameState.ultimateChargePoints + points
            );
            gameState.ultimateCharge = Math.min(
                100,
                (gameState.ultimateChargePoints / ULTIMATE_CHARGE_REQUIRED) * 100
            );
            updateUltimateBar();
        }

        function updateFragileMultiplier(deltaTime) {
            if (gameState.fragileMultiplier <= 1) return;
            gameState.fragileTimer -= deltaTime * 1000;
            if (gameState.fragileTimer <= 0) {
                gameState.fragileMultiplier = 1;
                gameState.fragileTimer = 0;
                updateFragileMultiplierDisplay();
            }
        }

        function explodeRandomPackages(count) {
            let exploded = 0;
            for (let i = 0; i < packages.length && exploded < count; i++) {
                const pkg = packages[i];
                if (!pkg.broken) {
                    breakPackage(pkg);
                    exploded++;
                }
            }
        }

        function triggerFragileBonus() {
            gameState.fragileMultiplier = FRAGILE_MULTIPLIER;
            gameState.fragileTimer = FRAGILE_MULTIPLIER_DURATION;
            updateFragileMultiplierDisplay();
            explodeRandomPackages(5);
            showFeedback('FRAGILE x3 ! +5 EXPLOSIONS', 'ultimate', window.innerWidth / 2, window.innerHeight / 2 + 80);
        }

        function triggerExpressBonus() {
            showFeedback('EXPRESS + BONUS!', 'ultimate', window.innerWidth / 2, window.innerHeight / 2 + 80);
            gameState.score += 75 * getEffectiveScoreMultiplier();
            updateScoreDisplay();
        }

        // Activate ultimate
        function activateUltimate() {
            if (gameState.ultimateCharge < 100 || gameState.ultimateActive) return;

            gameState.ultimateActive = true;
            gameState.ultimateTimer = ULTIMATE_DURATION;
            gameState.ultimatesUsed++;
            gameState.ultimateCharge = 100;
            gameState.ultimateChargePoints = 0;

            updateUltimateBar();
            showFeedback('ULTIMATE ACTIVE!', 'ultimate', window.innerWidth / 2, window.innerHeight / 2);
            playUltimateSound();
        }

        // Update ultimate timer
        function updateUltimate(deltaTime) {
            if (!gameState.ultimateActive) return;

            gameState.ultimateTimer -= deltaTime * 1000;
            gameState.ultimateCharge = (gameState.ultimateTimer / ULTIMATE_DURATION) * 100;
            updateUltimateBar();

            if (gameState.ultimateTimer <= 0) {
                gameState.ultimateActive = false;
                gameState.ultimateCharge = 0;
                gameState.ultimateChargePoints = 0;
                gameState.perfectStreak = 0;
                updateUltimateBar();
                updatePerfectStreak();
                showFeedback('ULTIMATE TERMINE', 'ok', window.innerWidth / 2, window.innerHeight / 2);
            }
        }

        // Handle keyboard input
        function handleKeyDown(e) {
            // Key binding mode
            if (listeningForKey) {
                handleKeyBinding(e);
                return;
            }

            const key = e.key.toLowerCase();
            pressedKeys[key] = true;

            // Pause handling
            if (key === 'escape') {
                if (gameState.isPlaying && !gameState.isPaused) {
                    pauseGame();
                } else if (gameState.isPaused) {
                    resumeGame();
                }
                return;
            }

            if (!gameState.isPlaying || gameState.isPaused) return;

            // Ultimate activation
            if (key === keyBindings.ultimate) {
                activateUltimate();
                return;
            }

            // Package controls
            let type = null;
            let keyElement = null;

            if (key === keyBindings.cube) {
                type = 'cube';
                keyElement = elements.keyA;
            } else if (key === keyBindings.sphere) {
                type = 'sphere';
                keyElement = elements.keyP;
            } else if (key === keyBindings.pizza) {
                e.preventDefault();
                type = 'pizza';
                keyElement = elements.keySpace;
            }

            if (keyElement) {
                keyElement.classList.add('active');
            }

            const cubeKey = keyBindings.cube;
            const sphereKey = keyBindings.sphere;
            if ((key === cubeKey || key === sphereKey) && pressedKeys[cubeKey] && pressedKeys[sphereKey]) {
                const hitFragile = checkFragileHit();
                if (hitFragile) {
                    return;
                }
            }

            const pizzaKey = keyBindings.pizza;
            if ((key === cubeKey || key === pizzaKey) && pressedKeys[cubeKey] && pressedKeys[pizzaKey]) {
                const hitExpress = checkExpressHit();
                if (hitExpress) {
                    return;
                }
            }

            if (type && !gameState.ultimateActive) {
                if (!checkNoteHit(type)) {
                    if ((type === 'cube' || type === 'sphere') && hasFragileNoteInWindow()) {
                        return;
                    }
                    if ((type === 'cube' || type === 'pizza') && hasExpressNoteInWindow()) {
                        return;
                    }
                    // Wrong timing - penalty
                    gameState.combo = 0;
                    gameState.perfectStreak = 0;
                    gameState.multiplier = 1;
                    gameState.comboPower = 1;
                    updateComboDisplay();
                    updatePerfectStreak();
                    updateUltimateBar();
                    applyMissPenalty({ playSound: true });
                }
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            pressedKeys[key] = false;

            if (key === keyBindings.cube) {
                elements.keyA.classList.remove('active');
            } else if (key === keyBindings.sphere) {
                elements.keyP.classList.remove('active');
            } else if (key === keyBindings.pizza) {
                elements.keySpace.classList.remove('active');
            }
        }

        // Handle mouse movement for power
        function handleMouseMove(e) {
            const normalizedY = 1 - (e.clientY / window.innerHeight);
            gameState.power = Math.max(0.2, Math.min(1, normalizedY));
            elements.powerFill.style.height = (gameState.power * 100) + '%';
        }

        // Pause game
        function pauseGame() {
            gameState.isPaused = true;
            elements.pauseScreen.style.display = 'flex';
            pauseUserTrack();
        }

        // Resume game
        function resumeGame() {
            gameState.isPaused = false;
            elements.pauseScreen.style.display = 'none';
            lastTime = performance.now();
            playUserTrack();
            requestAnimationFrame(gameLoop);
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Update physics
        function updatePhysics(deltaTime) {
            world.step(1 / 60, deltaTime, 3);

            for (let i = packages.length - 1; i >= 0; i--) {
                const pkg = packages[i];
                pkg.lifetime += deltaTime;

                if (pkg.body) {
                    pkg.mesh.position.copy(pkg.body.position);
                    pkg.mesh.quaternion.copy(pkg.body.quaternion);
                }

                const outOfBounds = pkg.mesh.position.y < -5 || pkg.mesh.position.z > 25 || pkg.mesh.position.z < -70;

                // Remove broken packages shortly after explosion or if they leave the truck area
                if ((pkg.broken && (pkg.lifetime - pkg.breakTime) > 1.5) || outOfBounds) {
                    scene.remove(pkg.mesh);
                    if (pkg.body) {
                        world.removeBody(pkg.body);
                    }
                    packages.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.velocity.y -= 20 * deltaTime;
                particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime));
                particle.rotation.x += particle.rotationSpeed.x * deltaTime;
                particle.rotation.y += particle.rotationSpeed.y * deltaTime;
                particle.rotation.z += particle.rotationSpeed.z * deltaTime;
                particle.lifetime += deltaTime;
                particle.material.opacity = 1 - (particle.lifetime / particle.maxLifetime);

                if (particle.lifetime > particle.maxLifetime) {
                    scene.remove(particle);
                    particles.splice(i, 1);
                }
            }
        }

        function isPackageInsideTruck(pkg) {
            const pos = pkg.mesh.position;
            return (
                pos.z < TRUCK_DIMENSIONS.doorZ &&
                pos.z > -TRUCK_DIMENSIONS.length + 2.4 &&
                Math.abs(pos.x) < TRUCK_DIMENSIONS.width / 2 + 0.2 &&
                pos.y > TRUCK_DIMENSIONS.floorY - 0.3
            );
        }

        function isPackageOverflowing(pkg) {
            const pos = pkg.mesh.position;
            const heightLimit = TRUCK_DIMENSIONS.height + TRUCK_DIMENSIONS.floorY + 0.4;
            return (
                pos.y > heightLimit ||
                pos.z > TRUCK_DIMENSIONS.doorZ + 0.4
            );
        }

        function checkTruckOverflow() {
            let loadedCount = 0;
            let overflowCount = 0;
            for (const pkg of packages) {
                if (pkg.broken) continue;
                if (isPackageInsideTruck(pkg)) {
                    loadedCount++;
                }
                if (isPackageOverflowing(pkg)) {
                    overflowCount++;
                }
            }
            return loadedCount >= TRUCK_CAPACITY && overflowCount >= TRUCK_OVERFLOW_LIMIT;
        }

        // Update timer display
        function updateTimer() {
            const remaining = Math.max(0, gameDuration - gameTime);
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            elements.timer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function getGameDurationMs() {
            if (useUserTrack && userTrack && Number.isFinite(userTrack.duration) && userTrack.duration > 0) {
                return userTrack.duration * 1000;
            }
            return DEFAULT_GAME_DURATION;
        }

        function updateGameDuration() {
            gameDuration = getGameDurationMs();
            updateTimer();
        }

        // Spawn beat notes
        let lastNoteSpawn = 0;
        function spawnBeatNotes(time) {
            const spawnInterval = 60000 / gameState.bpm / 2;
            const shouldForce = shouldForceSpawn(time);

            if (time - lastNoteSpawn > spawnInterval || shouldForce) {
                const shouldSpawn = shouldForce || Math.random() > 0.25;
                if (shouldSpawn && spawnNoteIfAllowed(time)) {
                    lastNoteSpawn = time;
                }
            }
        }

        let lastNoteSpawnAudio = 0;
        function spawnBeatNotesFromTrack(currentMs, force = false) {
            const baseInterval = Math.max(180, Math.min(500, gameState.beatInterval / 2));
            const shouldForce = shouldForceSpawn(currentMs);
            const shouldSpawn = (currentMs - lastNoteSpawnAudio) > baseInterval;

            if (force || shouldForce || shouldSpawn) {
                const shouldCreate = force || shouldForce || Math.random() > 0.15;
                if (shouldCreate && spawnNoteIfAllowed(currentMs)) {
                    lastNoteSpawnAudio = currentMs;
                }
            }
        }

        // Main game loop
        let lastTime = 0;
        let gameTime = 0;
        let gameDuration = DEFAULT_GAME_DURATION;

        function gameLoop(time) {
            if (!gameState.isPlaying) return;
            if (gameState.isPaused) return;

            requestAnimationFrame(gameLoop);

            const deltaTime = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;
            gameTime += deltaTime * 1000;

            // Update timer
            updateTimer();

            // Check game over
            if (gameTime >= gameDuration) {
                endGame();
                return;
            }

            // Spawn notes
            if (useUserTrack && userTrack && !userTrack.paused) {
                const beatHit = detectBeat();
                if (audioContext) {
                    spawnBeatNotesFromTrack(audioContext.currentTime * 1000, beatHit);
                }
            } else {
                spawnBeatNotes(time);
            }

            // Update beat notes
            updateBeatNotes(deltaTime);

            // Update ultimate
            updateUltimate(deltaTime);

            // Update fragile multiplier
            updateFragileMultiplier(deltaTime);

            // Update performance meter
            updatePerformanceMeter(deltaTime);

            // Update physics
            updatePhysics(deltaTime);

            // Check overflow loss
            if (checkTruckOverflow()) {
                endGame('Désolé, vous avez trop bien travaillé, les colis sont prêts à être livrés.');
                return;
            }

            // Play beat sounds
            if (!useUserTrack && time - gameState.lastBeatTime > gameState.beatInterval) {
                playBackgroundBeat();
                gameState.lastBeatTime = time;
            }

            // Render
            renderer.render(scene, camera);
        }

        // Start game
        function startGame() {
            // Reset state
            gameState.score = 0;
            gameState.combo = 0;
            gameState.maxCombo = 0;
            gameState.multiplier = 1;
            gameState.comboPower = 1;
            gameState.brokenPackages = 0;
            gameState.totalNotes = 0;
            gameState.hitNotes = 0;
            gameState.perfectStreak = 0;
            gameState.ultimateCharge = 0;
            gameState.ultimateChargePoints = 0;
            gameState.ultimateActive = false;
            gameState.ultimateTimer = 0;
            gameState.ultimatesUsed = 0;
            gameState.fragileMultiplier = 1;
            gameState.fragileTimer = 0;
            gameState.recentNoteResults = [];
            gameState.dangerTimer = 0;
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameTime = 0;
            updateGameDuration();
            lastNoteSpawn = 0;
            lastNoteSpawnAudio = 0;
            noteSpawnTimestamps.length = 0;
            lastNoteSpawnTime = 0;
            lastNoteSpawnWidth = NOTE_WIDTH;
            lastComboNoteTime = -Infinity;
            lastRegularNoteTime = -Infinity;
            beatDetector.energyAvg = 0;
            beatDetector.energyHistory = [];
            beatDetector.lastBeatTime = 0;
            beatDetector.prevBeatTime = 0;

            // Clear existing
            beatNotes.forEach(n => n.element.remove());
            beatNotes = [];
            packages.forEach(p => {
                scene.remove(p.mesh);
                if (p.body) {
                    world.removeBody(p.body);
                }
            });
            packages = [];
            particles.forEach(p => scene.remove(p));
            particles = [];

            // Update UI
            updateScoreDisplay();
            updateComboDisplay();
            updatePerfectStreak();
            updateUltimateBar();
            updateFragileMultiplierDisplay();
            updatePerformanceIndicator();
            elements.brokenValue.textContent = '0';

            // Hide screens
            elements.startScreen.classList.add('hidden');
            elements.gameOverScreen.style.display = 'none';
            elements.pauseScreen.style.display = 'none';

            // Initialize audio on user interaction
            if (!audioContext) {
                initAudio();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            pendingTrackPlayback = false;
            if (analysisInProgress) {
                pendingTrackPlayback = true;
            } else {
                playUserTrack(true);
            }

            // Start game loop
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // End game
        function endGame(reasonMessage = '') {
            gameState.isPlaying = false;
            pauseUserTrack();
            gameState.fragileMultiplier = 1;
            gameState.fragileTimer = 0;
            updateFragileMultiplierDisplay();

            // Show game over screen
            elements.gameOverScreen.style.display = 'flex';
            elements.finalScore.textContent = gameState.score.toLocaleString();
            elements.statBroken.textContent = gameState.brokenPackages;
            elements.statCombo.textContent = gameState.maxCombo;
            elements.statUltimates.textContent = gameState.ultimatesUsed;

            const accuracy = gameState.totalNotes > 0
                ? Math.round((gameState.hitNotes / gameState.totalNotes) * 100)
                : 0;
            elements.statAccuracy.textContent = accuracy + '%';
            elements.gameOverMessage.textContent = reasonMessage;
            elements.gameOverMessage.style.display = reasonMessage ? 'block' : 'none';
        }

        // Go to menu
        function goToMenu() {
            gameState.isPlaying = false;
            gameState.isPaused = false;
            pauseUserTrack();
            elements.startScreen.classList.remove('hidden');
            elements.gameOverScreen.style.display = 'none';
            elements.pauseScreen.style.display = 'none';
            elements.gameOverMessage.textContent = '';
            elements.gameOverMessage.style.display = 'none';
        }

        // Initialize everything
        function init() {
            initScene();
            initPhysics();
            setupKeyBindingListeners();
            setupDifficultyListeners();
            updateKeyDisplays();
            updateDifficultySelection(currentDifficulty);
            updateGameDuration();
            updateFragileMultiplierDisplay();

            // Event listeners
            elements.startBtn.addEventListener('click', startGame);
            elements.restartBtn.addEventListener('click', startGame);
            elements.menuBtn.addEventListener('click', goToMenu);
            elements.resumeBtn.addEventListener('click', resumeGame);
            elements.quitBtn.addEventListener('click', goToMenu);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            document.addEventListener('mousemove', handleMouseMove);
            elements.musicUpload.addEventListener('change', handleMusicUpload);
            elements.analysisUpload.addEventListener('change', handleAnalysisUpload);
            elements.analyzeBtn.addEventListener('click', analyzeCurrentTrack);
            elements.exportBtn.addEventListener('click', exportAnalysisJson);
            elements.trackSelect.addEventListener('change', (event) => {
                applyTrackSelection(event.target.value);
            });
            updateTrackStatus('Aucune', false);

            const savedTrack = localStorage.getItem('atomic-parcel-track') || 'atomic-parcel';
            elements.trackSelect.value = savedTrack;
            applyTrackSelection(savedTrack, { persist: false });

            // Initial render
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
